### YamlMime:ManagedReference
items:
- uid: Open.ChannelExtensions.Extensions
  commentId: T:Open.ChannelExtensions.Extensions
  id: Extensions
  parent: Open.ChannelExtensions
  children:
  - Open.ChannelExtensions.Extensions.Batch``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Boolean)
  - Open.ChannelExtensions.Extensions.CompleteAsync``2(System.Threading.Channels.Channel{``0,``1},System.Exception)
  - Open.ChannelExtensions.Extensions.Filter``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Boolean})
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{``0[]},System.Boolean)
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{``0}},System.Boolean)
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{``0}},System.Boolean)
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{``0}},System.Boolean)
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.List{``0}},System.Boolean)
  - Open.ChannelExtensions.Extensions.OfType``2(System.Threading.Channels.ChannelReader{``0})
  - Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Action{``0},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Action{``1},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAvailable``1(System.Threading.Channels.ChannelReader{``0})
  - Open.ChannelExtensions.Extensions.ReadBatchAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Transform``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1})
  - Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  langs:
  - csharp
  - vb
  name: Extensions
  nameWithType: Extensions
  fullName: Open.ChannelExtensions.Extensions
  type: Class
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Extensions
    path: Extensions._.cs
    startLine: 12
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nExtensions for operating with System.Threading.Channels.\n"
  example: []
  syntax:
    content: public static class Extensions
    content.vb: Public Module Extensions
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
  modifiers.csharp:
  - public
  - static
  - class
  modifiers.vb:
  - Public
  - Module
- uid: Open.ChannelExtensions.Extensions.Batch``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Batch``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Boolean)
  id: Batch``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Batch<T>(ChannelReader<T>, Int32, Boolean)
  nameWithType: Extensions.Batch<T>(ChannelReader<T>, Int32, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Batch<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Batch.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Batch
    path: Extensions.Batch.cs
    startLine: 78
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nBatches results into the batch size provided with a max capacity of batches.\n"
  example: []
  syntax:
    content: public static ChannelReader<List<T>> Batch<T>(this ChannelReader<T> source, int batchSize, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel to read from.
    - id: batchSize
      type: System.Int32
      description: The maximum size of each batch.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The output type of the source channel.
    return:
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.List{{T}}}
      description: A channel reader containing the batches.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Batch(Of T)(source As ChannelReader(Of T), batchSize As Integer, singleReader As Boolean = False) As ChannelReader(Of List(Of T))
  overload: Open.ChannelExtensions.Extensions.Batch*
  nameWithType.vb: Extensions.Batch(Of T)(ChannelReader(Of T), Int32, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Batch(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Boolean)
  name.vb: Batch(Of T)(ChannelReader(Of T), Int32, Boolean)
- uid: Open.ChannelExtensions.Extensions.Filter``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Boolean})
  commentId: M:Open.ChannelExtensions.Extensions.Filter``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Boolean})
  id: Filter``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Boolean})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Filter<T>(ChannelReader<T>, Func<T, Boolean>)
  nameWithType: Extensions.Filter<T>(ChannelReader<T>, Func<T, Boolean>)
  fullName: Open.ChannelExtensions.Extensions.Filter<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Boolean>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Filter.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Filter
    path: Extensions.Filter.cs
    startLine: 48
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nProduces a reader that only contains results that pass the predicate condition.  Ones that fail the predicate are discarded.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Filter<T>(this ChannelReader<T> source, Func<T, bool> predicate)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The source channel reader.
    - id: predicate
      type: System.Func{{T},System.Boolean}
      description: The predicate function.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader representing the filtered results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Filter(Of T)(source As ChannelReader(Of T), predicate As Func(Of T, Boolean)) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Filter*
  nameWithType.vb: Extensions.Filter(Of T)(ChannelReader(Of T), Func(Of T, Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Filter(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Boolean))
  name.vb: Filter(Of T)(ChannelReader(Of T), Func(Of T, Boolean))
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{``0}},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{``0}},System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{``0}},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<IEnumerable<T>>, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<IEnumerable<T>>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<System.Collections.Generic.IEnumerable<T>>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: Extensions.Join.cs
    startLine: 44
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<IEnumerable<T>> source, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{{T}}}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of IEnumerable(Of T)), singleReader As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of IEnumerable(Of T)), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of System.Collections.Generic.IEnumerable(Of T)), System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of IEnumerable(Of T)), Boolean)
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{``0}},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{``0}},System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{``0}},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<ICollection<T>>, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<ICollection<T>>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<System.Collections.Generic.ICollection<T>>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: Extensions.Join.cs
    startLine: 54
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<ICollection<T>> source, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{{T}}}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of ICollection(Of T)), singleReader As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of ICollection(Of T)), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of System.Collections.Generic.ICollection(Of T)), System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of ICollection(Of T)), Boolean)
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{``0}},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{``0}},System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{``0}},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<IList<T>>, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<IList<T>>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<System.Collections.Generic.IList<T>>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: Extensions.Join.cs
    startLine: 64
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<IList<T>> source, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{{T}}}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of IList(Of T)), singleReader As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of IList(Of T)), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of System.Collections.Generic.IList(Of T)), System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of IList(Of T)), Boolean)
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.List{``0}},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.List{``0}},System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.List{``0}},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<List<T>>, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<List<T>>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<System.Collections.Generic.List<T>>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: Extensions.Join.cs
    startLine: 74
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<List<T>> source, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.List{{T}}}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of List(Of T)), singleReader As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of List(Of T)), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of System.Collections.Generic.List(Of T)), System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of List(Of T)), Boolean)
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{``0[]},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{``0[]},System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{``0[]},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<T[]>, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<T[]>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<T[]>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: Extensions.Join.cs
    startLine: 84
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<T[]> source, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{T}[]}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of T()), singleReader As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of T()), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of T()), System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of T()), Boolean)
- uid: Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: PipeAsync<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.PipeAsync<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.PipeAsync<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Int32, System.Func<TIn, System.Threading.Tasks.ValueTask<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: PipeAsync
    path: Extensions.Pipe.cs
    startLine: 21
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries concurrently and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> PipeAsync<TIn, TOut>(this ChannelReader<TIn> source, int maxConcurrency, Func<TIn, ValueTask<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: transform
      type: System.Func{{TIn},System.Threading.Tasks.ValueTask{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function PipeAsync(Of TIn, TOut)(source As ChannelReader(Of TIn), maxConcurrency As Integer, transform As Func(Of TIn, ValueTask(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.PipeAsync*
  nameWithType.vb: Extensions.PipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.PipeAsync(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Int32, System.Func(Of TIn, System.Threading.Tasks.ValueTask(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: PipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: PipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.PipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.PipeAsync<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Func<TRead, System.Threading.Tasks.ValueTask<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: PipeAsync
    path: Extensions.Pipe.cs
    startLine: 61
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> PipeAsync<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, int maxConcurrency, Func<TRead, ValueTask<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: transform
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function PipeAsync(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), maxConcurrency As Integer, transform As Func(Of TRead, ValueTask(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.PipeAsync*
  nameWithType.vb: Extensions.PipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.PipeAsync(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Func(Of TRead, System.Threading.Tasks.ValueTask(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: PipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskPipeAsync<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, Task<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.TaskPipeAsync<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, Task<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskPipeAsync<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Int32, System.Func<TIn, System.Threading.Tasks.Task<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskPipeAsync
    path: Extensions.Pipe.cs
    startLine: 78
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> TaskPipeAsync<TIn, TOut>(this ChannelReader<TIn> source, int maxConcurrency, Func<TIn, Task<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: transform
      type: System.Func{{TIn},System.Threading.Tasks.Task{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskPipeAsync(Of TIn, TOut)(source As ChannelReader(Of TIn), maxConcurrency As Integer, transform As Func(Of TIn, Task(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.TaskPipeAsync*
  nameWithType.vb: Extensions.TaskPipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, Task(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskPipeAsync(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Int32, System.Func(Of TIn, System.Threading.Tasks.Task(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskPipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, Task(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskPipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, Task<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.TaskPipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, Task<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskPipeAsync<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Func<TRead, System.Threading.Tasks.Task<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskPipeAsync
    path: Extensions.Pipe.cs
    startLine: 96
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> TaskPipeAsync<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, int maxConcurrency, Func<TRead, Task<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: transform
      type: System.Func{{TRead},System.Threading.Tasks.Task{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskPipeAsync(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), maxConcurrency As Integer, transform As Func(Of TRead, Task(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.TaskPipeAsync*
  nameWithType.vb: Extensions.TaskPipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, Task(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskPipeAsync(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Func(Of TRead, System.Threading.Tasks.Task(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskPipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, Task(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Pipe<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, TOut>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.Pipe<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, TOut>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Pipe<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Int32, System.Func<TIn, TOut>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Pipe
    path: Extensions.Pipe.cs
    startLine: 113
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> Pipe<TIn, TOut>(this ChannelReader<TIn> source, int maxConcurrency, Func<TIn, TOut> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: transform
      type: System.Func{{TIn},{TOut}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Pipe(Of TIn, TOut)(source As ChannelReader(Of TIn), maxConcurrency As Integer, transform As Func(Of TIn, TOut), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.Pipe*
  nameWithType.vb: Extensions.Pipe(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, TOut), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Pipe(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Int32, System.Func(Of TIn, TOut), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: Pipe(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, TOut), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Pipe<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, TOut>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.Pipe<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, TOut>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Pipe<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Func<TRead, TOut>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Pipe
    path: Extensions.Pipe.cs
    startLine: 131
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> Pipe<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, int maxConcurrency, Func<TRead, TOut> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: transform
      type: System.Func{{TRead},{TOut}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Pipe(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), maxConcurrency As Integer, transform As Func(Of TRead, TOut), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.Pipe*
  nameWithType.vb: Extensions.Pipe(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, TOut), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Pipe(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Func(Of TRead, TOut), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: Pipe(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, TOut), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: PipeAsync<TIn, TOut>(ChannelReader<TIn>, Func<TIn, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.PipeAsync<TIn, TOut>(ChannelReader<TIn>, Func<TIn, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.PipeAsync<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Func<TIn, System.Threading.Tasks.ValueTask<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: PipeAsync
    path: Extensions.Pipe.cs
    startLine: 147
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> PipeAsync<TIn, TOut>(this ChannelReader<TIn> source, Func<TIn, ValueTask<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: transform
      type: System.Func{{TIn},System.Threading.Tasks.ValueTask{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function PipeAsync(Of TIn, TOut)(source As ChannelReader(Of TIn), transform As Func(Of TIn, ValueTask(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.PipeAsync*
  nameWithType.vb: Extensions.PipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.PipeAsync(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Func(Of TIn, System.Threading.Tasks.ValueTask(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: PipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: PipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.PipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.PipeAsync<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Threading.Tasks.ValueTask<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: PipeAsync
    path: Extensions.Pipe.cs
    startLine: 164
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> PipeAsync<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, Func<TRead, ValueTask<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: transform
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function PipeAsync(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), transform As Func(Of TRead, ValueTask(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.PipeAsync*
  nameWithType.vb: Extensions.PipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.PipeAsync(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Threading.Tasks.ValueTask(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: PipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskPipeAsync<TIn, TOut>(ChannelReader<TIn>, Func<TIn, Task<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.TaskPipeAsync<TIn, TOut>(ChannelReader<TIn>, Func<TIn, Task<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskPipeAsync<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Func<TIn, System.Threading.Tasks.Task<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskPipeAsync
    path: Extensions.Pipe.cs
    startLine: 180
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> TaskPipeAsync<TIn, TOut>(this ChannelReader<TIn> source, Func<TIn, Task<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: transform
      type: System.Func{{TIn},System.Threading.Tasks.Task{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskPipeAsync(Of TIn, TOut)(source As ChannelReader(Of TIn), transform As Func(Of TIn, Task(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.TaskPipeAsync*
  nameWithType.vb: Extensions.TaskPipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, Task(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskPipeAsync(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Func(Of TIn, System.Threading.Tasks.Task(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskPipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, Task(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskPipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, Task<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.TaskPipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, Task<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskPipeAsync<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Threading.Tasks.Task<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskPipeAsync
    path: Extensions.Pipe.cs
    startLine: 197
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> TaskPipeAsync<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, Func<TRead, Task<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: transform
      type: System.Func{{TRead},System.Threading.Tasks.Task{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskPipeAsync(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), transform As Func(Of TRead, Task(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.TaskPipeAsync*
  nameWithType.vb: Extensions.TaskPipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, Task(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskPipeAsync(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Threading.Tasks.Task(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskPipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, Task(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Pipe<TIn, TOut>(ChannelReader<TIn>, Func<TIn, TOut>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.Pipe<TIn, TOut>(ChannelReader<TIn>, Func<TIn, TOut>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Pipe<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Func<TIn, TOut>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Pipe
    path: Extensions.Pipe.cs
    startLine: 213
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> Pipe<TIn, TOut>(this ChannelReader<TIn> source, Func<TIn, TOut> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: transform
      type: System.Func{{TIn},{TOut}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Pipe(Of TIn, TOut)(source As ChannelReader(Of TIn), transform As Func(Of TIn, TOut), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.Pipe*
  nameWithType.vb: Extensions.Pipe(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, TOut), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Pipe(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Func(Of TIn, TOut), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: Pipe(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, TOut), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Pipe<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, TOut>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.Pipe<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, TOut>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Pipe<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, TOut>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Pipe
    path: Extensions.Pipe.cs
    startLine: 230
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> Pipe<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, Func<TRead, TOut> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: transform
      type: System.Func{{TRead},{TOut}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Pipe(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), transform As Func(Of TRead, TOut), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.Pipe*
  nameWithType.vb: Extensions.Pipe(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, TOut), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Pipe(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, TOut), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: Pipe(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, TOut), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAvailable``1(System.Threading.Channels.ChannelReader{``0})
  commentId: M:Open.ChannelExtensions.Extensions.ReadAvailable``1(System.Threading.Channels.ChannelReader{``0})
  id: ReadAvailable``1(System.Threading.Channels.ChannelReader{``0})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAvailable<T>(ChannelReader<T>)
  nameWithType: Extensions.ReadAvailable<T>(ChannelReader<T>)
  fullName: Open.ChannelExtensions.Extensions.ReadAvailable<T>(System.Threading.Channels.ChannelReader<T>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAvailable
    path: Extensions.Read.cs
    startLine: 19
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nCreates an enumerable that will read from the channel until no more are available for read.\n"
  example: []
  syntax:
    content: public static IEnumerable<T> ReadAvailable<T>(this ChannelReader<T> reader)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Collections.Generic.IEnumerable{{T}}
      description: An enumerable that will read from the channel until no more are available for read
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAvailable(Of T)(reader As ChannelReader(Of T)) As IEnumerable(Of T)
  overload: Open.ChannelExtensions.Extensions.ReadAvailable*
  nameWithType.vb: Extensions.ReadAvailable(Of T)(ChannelReader(Of T))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAvailable(Of T)(System.Threading.Channels.ChannelReader(Of T))
  name.vb: ReadAvailable(Of T)(ChannelReader(Of T))
- uid: Open.ChannelExtensions.Extensions.ReadBatchAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadBatchAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken)
  id: ReadBatchAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadBatchAsync<T>(ChannelReader<T>, Int32, CancellationToken)
  nameWithType: Extensions.ReadBatchAsync<T>(ChannelReader<T>, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadBatchAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadBatchAsync
    path: Extensions.Read.cs
    startLine: 36
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads from the channel up to the max count.\n"
  example: []
  syntax:
    content: public static ValueTask<List<T>> ReadBatchAsync<T>(this ChannelReader<T> reader, int max, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: max
      type: System.Int32
      description: The max size of the batch.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Collections.Generic.List{{T}}}
      description: The batch requested.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadBatchAsync(Of T)(reader As ChannelReader(Of T), max As Integer, cancellationToken As CancellationToken = Nothing) As ValueTask(Of List(Of T))
  overload: Open.ChannelExtensions.Extensions.ReadBatchAsync*
  nameWithType.vb: Extensions.ReadBatchAsync(Of T)(ChannelReader(Of T), Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadBatchAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Threading.CancellationToken)
  name.vb: ReadBatchAsync(Of T)(ChannelReader(Of T), Int32, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelledAsync<T>(ChannelReader<T>, CancellationToken, Func<T, Int64, ValueTask>, Boolean)
  nameWithType: Extensions.ReadUntilCancelledAsync<T>(ChannelReader<T>, CancellationToken, Func<T, Int64, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Func<T, System.Int64, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelledAsync
    path: Extensions.Read.cs
    startLine: 75
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelledAsync<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Func<T, long, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{T},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelledAsync(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Func(Of T, Long, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync*
  nameWithType.vb: Extensions.ReadUntilCancelledAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, Int64, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Func(Of T, System.Int64, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadUntilCancelledAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, Int64, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelledAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, Int64, ValueTask>, Boolean)
  nameWithType: Extensions.ReadUntilCancelledAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, Int64, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Func<TRead, System.Int64, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelledAsync
    path: Extensions.Read.cs
    startLine: 118
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelledAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Func<TRead, long, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{TRead},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelledAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Func(Of TRead, Long, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync*
  nameWithType.vb: Extensions.ReadUntilCancelledAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, Int64, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Func(Of TRead, System.Int64, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadUntilCancelledAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, Int64, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelledAsync<T>(ChannelReader<T>, CancellationToken, Func<T, ValueTask>, Boolean)
  nameWithType: Extensions.ReadUntilCancelledAsync<T>(ChannelReader<T>, CancellationToken, Func<T, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Func<T, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelledAsync
    path: Extensions.Read.cs
    startLine: 134
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelledAsync<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Func<T, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelledAsync(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Func(Of T, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync*
  nameWithType.vb: Extensions.ReadUntilCancelledAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Func(Of T, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadUntilCancelledAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelledAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, ValueTask>, Boolean)
  nameWithType: Extensions.ReadUntilCancelledAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Func<TRead, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelledAsync
    path: Extensions.Read.cs
    startLine: 151
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelledAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Func<TRead, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelledAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Func(Of TRead, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync*
  nameWithType.vb: Extensions.ReadUntilCancelledAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Func(Of TRead, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadUntilCancelledAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  id: ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelled<T>(ChannelReader<T>, CancellationToken, Action<T, Int64>, Boolean)
  nameWithType: Extensions.ReadUntilCancelled<T>(ChannelReader<T>, CancellationToken, Action<T, Int64>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelled<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Action<T, System.Int64>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelled
    path: Extensions.Read.cs
    startLine: 167
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelled<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Action<T, long> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Action{{T},System.Int64}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelled(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Action(Of T, Long), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelled*
  nameWithType.vb: Extensions.ReadUntilCancelled(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T, Int64), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelled(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Action(Of T, System.Int64), System.Boolean)
  name.vb: ReadUntilCancelled(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T, Int64), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  id: ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelled<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Action<TRead, Int64>, Boolean)
  nameWithType: Extensions.ReadUntilCancelled<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Action<TRead, Int64>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelled<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Action<TRead, System.Int64>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelled
    path: Extensions.Read.cs
    startLine: 192
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelled<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Action<TRead, long> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Action{{TRead},System.Int64}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelled(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Action(Of TRead, Long), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelled*
  nameWithType.vb: Extensions.ReadUntilCancelled(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Action(Of TRead, Int64), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelled(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Action(Of TRead, System.Int64), System.Boolean)
  name.vb: ReadUntilCancelled(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Action(Of TRead, Int64), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  id: ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelled<T>(ChannelReader<T>, CancellationToken, Action<T>, Boolean)
  nameWithType: Extensions.ReadUntilCancelled<T>(ChannelReader<T>, CancellationToken, Action<T>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelled<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Action<T>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelled
    path: Extensions.Read.cs
    startLine: 208
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelled<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Action<T> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Action{{T}}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelled(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Action(Of T), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelled*
  nameWithType.vb: Extensions.ReadUntilCancelled(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelled(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Action(Of T), System.Boolean)
  name.vb: ReadUntilCancelled(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  id: ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelled<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadUntilCancelled<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelled<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Action<TRead>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelled
    path: Extensions.Read.cs
    startLine: 232
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelled<TWrite, TRead>(this Channel<TWrite, TRead> channel, Action<TRead> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Action{{TRead}}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelled(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Action(Of TRead), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelled*
  nameWithType.vb: Extensions.ReadUntilCancelled(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelled(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Action(Of TRead), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadUntilCancelled(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<T>(ChannelReader<T>, Func<T, Int64, ValueTask>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsync<T>(ChannelReader<T>, Func<T, Int64, ValueTask>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Int64, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: Extensions.Read.cs
    startLine: 248
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<T>(this ChannelReader<T> reader, Func<T, long, ValueTask> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Func{{T},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of T)(reader As ChannelReader(Of T), receiver As Func(Of T, Long, ValueTask), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Int64, ValueTask), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Int64, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Int64, ValueTask), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, ValueTask>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, ValueTask>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Int64, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: Extensions.Read.cs
    startLine: 269
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, long, ValueTask> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, Long, ValueTask), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, ValueTask), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Int64, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, ValueTask), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  id: TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, Task>, CancellationToken, Boolean)
  nameWithType: Extensions.TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, Task>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Int64, System.Threading.Tasks.Task>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: Extensions.Read.cs
    startLine: 286
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, long, Task> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Int64,System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, Long, Task), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, Task), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Int64, System.Threading.Tasks.Task), System.Threading.CancellationToken, System.Boolean)
  name.vb: TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, Task), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<T>(ChannelReader<T>, Func<T, ValueTask>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsync<T>(ChannelReader<T>, Func<T, ValueTask>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: Extensions.Read.cs
    startLine: 302
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<T>(this ChannelReader<T> reader, Func<T, ValueTask> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of T)(reader As ChannelReader(Of T), receiver As Func(Of T, ValueTask), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, ValueTask), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, ValueTask), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  id: TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<T>(ChannelReader<T>, Func<T, Task>, CancellationToken, Boolean)
  nameWithType: Extensions.TaskReadAllAsync<T>(ChannelReader<T>, Func<T, Task>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Threading.Tasks.Task>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: Extensions.Read.cs
    startLine: 318
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<T>(this ChannelReader<T> reader, Func<T, Task> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of T)(reader As ChannelReader(Of T), receiver As Func(Of T, Task), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Task), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Threading.Tasks.Task), System.Threading.CancellationToken, System.Boolean)
  name.vb: TaskReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Task), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  id: TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Task>, CancellationToken, Boolean)
  nameWithType: Extensions.TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Task>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Threading.Tasks.Task>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: Extensions.Read.cs
    startLine: 335
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, Task> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, Task), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Task), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Threading.Tasks.Task), System.Threading.CancellationToken, System.Boolean)
  name.vb: TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Task), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, ValueTask>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, ValueTask>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: Extensions.Read.cs
    startLine: 352
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, ValueTask> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, ValueTask), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, ValueTask), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, ValueTask), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Threading.CancellationToken,System.Boolean)
  id: ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<T>(ChannelReader<T>, Action<T, Int64>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAll<T>(ChannelReader<T>, Action<T, Int64>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<T>(System.Threading.Channels.ChannelReader<T>, System.Action<T, System.Int64>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: Extensions.Read.cs
    startLine: 368
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<T>(this ChannelReader<T> reader, Action<T, long> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Action{{T},System.Int64}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writreadinging.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of T)(reader As ChannelReader(Of T), receiver As Action(Of T, Long), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of T)(ChannelReader(Of T), Action(Of T, Int64), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Action(Of T, System.Int64), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAll(Of T)(ChannelReader(Of T), Action(Of T, Int64), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Threading.CancellationToken,System.Boolean)
  id: ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead, Int64>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead, Int64>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Action<TRead, System.Int64>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: Extensions.Read.cs
    startLine: 398
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<TWrite, TRead>(this Channel<TWrite, TRead> channel, Action<TRead, long> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Action{{TRead},System.Int64}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Action(Of TRead, Long), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead, Int64), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Action(Of TRead, System.Int64), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead, Int64), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Threading.CancellationToken,System.Boolean)
  id: ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<T>(ChannelReader<T>, Action<T>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAll<T>(ChannelReader<T>, Action<T>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<T>(System.Threading.Channels.ChannelReader<T>, System.Action<T>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: Extensions.Read.cs
    startLine: 414
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<T>(this ChannelReader<T> reader, Action<T> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Action{{T}}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of T)(reader As ChannelReader(Of T), receiver As Action(Of T), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of T)(ChannelReader(Of T), Action(Of T), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Action(Of T), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAll(Of T)(ChannelReader(Of T), Action(Of T), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  id: ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Action<TRead>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: Extensions.Read.cs
    startLine: 444
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<TWrite, TRead>(this Channel<TWrite, TRead> channel, Action<TRead> receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Action{{TRead}}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Action(Of TRead), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Action(Of TRead), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsLines(ChannelReader<String>, TextWriter, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsLines(ChannelReader<String>, TextWriter, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader<System.String>, System.IO.TextWriter, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsLines
    path: Extensions.Read.cs
    startLine: 459
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and writes to the target writer.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsLines(this ChannelReader<string> reader, TextWriter receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{System.String}
      description: The channel reader to read from.
    - id: receiver
      type: System.IO.TextWriter
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsLines(reader As ChannelReader(Of String), receiver As TextWriter, cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsLines*
  nameWithType.vb: Extensions.ReadAllAsLines(ChannelReader(Of String), TextWriter, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader(Of System.String), System.IO.TextWriter, System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsLines(ChannelReader(Of String), TextWriter, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsLines<T>(Channel<T, String>, TextWriter, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsLines<T>(Channel<T, String>, TextWriter, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsLines<T>(System.Threading.Channels.Channel<T, System.String>, System.IO.TextWriter, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsLines
    path: Extensions.Read.cs
    startLine: 475
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and writes to the target writer.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsLines<T>(this Channel<T, string> channel, TextWriter receiver, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{T},System.String}
      description: The channel to read from.
    - id: receiver
      type: System.IO.TextWriter
      description: The TextWriter to recieve the lines.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items read that completes when no more reading is to be done.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsLines(Of T)(channel As Channel(Of T, String), receiver As TextWriter, cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsLines*
  nameWithType.vb: Extensions.ReadAllAsLines(Of T)(Channel(Of T, String), TextWriter, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsLines(Of T)(System.Threading.Channels.Channel(Of T, System.String), System.IO.TextWriter, System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsLines(Of T)(Channel(Of T, String), TextWriter, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  id: ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrentlyAsync<T>(ChannelReader<T>, Int32, Func<T, ValueTask>, CancellationToken)
  nameWithType: Extensions.ReadAllConcurrentlyAsync<T>(ChannelReader<T>, Int32, Func<T, ValueTask>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Func<T, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrentlyAsync
    path: Extensions.ReadConcurrently.cs
    startLine: 20
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrentlyAsync<T>(this ChannelReader<T> reader, int maxConcurrency, Func<T, ValueTask> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrentlyAsync(Of T)(reader As ChannelReader(Of T), maxConcurrency As Integer, receiver As Func(Of T, ValueTask), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync*
  nameWithType.vb: Extensions.ReadAllConcurrentlyAsync(Of T)(ChannelReader(Of T), Int32, Func(Of T, ValueTask), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Func(Of T, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken)
  name.vb: ReadAllConcurrentlyAsync(Of T)(ChannelReader(Of T), Int32, Func(Of T, ValueTask), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  id: TaskReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllConcurrentlyAsync<T>(ChannelReader<T>, Int32, Func<T, Task>, CancellationToken)
  nameWithType: Extensions.TaskReadAllConcurrentlyAsync<T>(ChannelReader<T>, Int32, Func<T, Task>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Func<T, System.Threading.Tasks.Task>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllConcurrentlyAsync
    path: Extensions.ReadConcurrently.cs
    startLine: 57
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> TaskReadAllConcurrentlyAsync<T>(this ChannelReader<T> reader, int maxConcurrency, Func<T, Task> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllConcurrentlyAsync(Of T)(reader As ChannelReader(Of T), maxConcurrency As Integer, receiver As Func(Of T, Task), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync*
  nameWithType.vb: Extensions.TaskReadAllConcurrentlyAsync(Of T)(ChannelReader(Of T), Int32, Func(Of T, Task), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Func(Of T, System.Threading.Tasks.Task), System.Threading.CancellationToken)
  name.vb: TaskReadAllConcurrentlyAsync(Of T)(ChannelReader(Of T), Int32, Func(Of T, Task), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  id: ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrentlyAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Func<TRead, ValueTask>, CancellationToken)
  nameWithType: Extensions.ReadAllConcurrentlyAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Func<TRead, ValueTask>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Func<TRead, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrentlyAsync
    path: Extensions.ReadConcurrently.cs
    startLine: 73
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrentlyAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, int maxConcurrency, Func<TRead, ValueTask> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrentlyAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), maxConcurrency As Integer, receiver As Func(Of TRead, ValueTask), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync*
  nameWithType.vb: Extensions.ReadAllConcurrentlyAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, ValueTask), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Func(Of TRead, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken)
  name.vb: ReadAllConcurrentlyAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, ValueTask), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  id: TaskReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllConcurrentlyAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Func<TRead, Task>, CancellationToken)
  nameWithType: Extensions.TaskReadAllConcurrentlyAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Func<TRead, Task>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Func<TRead, System.Threading.Tasks.Task>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllConcurrentlyAsync
    path: Extensions.ReadConcurrently.cs
    startLine: 89
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> TaskReadAllConcurrentlyAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, int maxConcurrency, Func<TRead, Task> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllConcurrentlyAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), maxConcurrency As Integer, receiver As Func(Of TRead, Task), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync*
  nameWithType.vb: Extensions.TaskReadAllConcurrentlyAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, Task), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Func(Of TRead, System.Threading.Tasks.Task), System.Threading.CancellationToken)
  name.vb: TaskReadAllConcurrentlyAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, Task), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Action{``0},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Action{``0},System.Threading.CancellationToken)
  id: ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Action{``0},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrently<T>(ChannelReader<T>, Int32, Action<T>, CancellationToken)
  nameWithType: Extensions.ReadAllConcurrently<T>(ChannelReader<T>, Int32, Action<T>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrently<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Action<T>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrently
    path: Extensions.ReadConcurrently.cs
    startLine: 104
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrently<T>(this ChannelReader<T> reader, int maxConcurrency, Action<T> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: receiver
      type: System.Action{{T}}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrently(Of T)(reader As ChannelReader(Of T), maxConcurrency As Integer, receiver As Action(Of T), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrently*
  nameWithType.vb: Extensions.ReadAllConcurrently(Of T)(ChannelReader(Of T), Int32, Action(Of T), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrently(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Action(Of T), System.Threading.CancellationToken)
  name.vb: ReadAllConcurrently(Of T)(ChannelReader(Of T), Int32, Action(Of T), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Action{``1},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Action{``1},System.Threading.CancellationToken)
  id: ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Action{``1},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrently<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Action<TRead>, CancellationToken)
  nameWithType: Extensions.ReadAllConcurrently<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Action<TRead>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrently<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Action<TRead>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrently
    path: Extensions.ReadConcurrently.cs
    startLine: 126
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrently<TWrite, TRead>(this Channel<TWrite, TRead> channel, int maxConcurrency, Action<TRead> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: receiver
      type: System.Action{{TRead}}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrently(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), maxConcurrency As Integer, receiver As Action(Of TRead), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrently*
  nameWithType.vb: Extensions.ReadAllConcurrently(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Action(Of TRead), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrently(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Action(Of TRead), System.Threading.CancellationToken)
  name.vb: ReadAllConcurrently(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Action(Of TRead), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken,System.Boolean)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Func<TWrite>>, CancellationToken, Boolean)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Func<TWrite>>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<System.Func<TWrite>>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: Extensions.Source.cs
    startLine: 21
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nExecutes all entries from the source and passes their result to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<Func<TWrite>> source, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of Func(Of TWrite)), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Func(Of TWrite)), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of System.Func(Of TWrite)), System.Threading.CancellationToken, System.Boolean)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Func(Of TWrite)), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken,System.Boolean)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<ValueTask<TWrite>>, CancellationToken, Boolean)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<ValueTask<TWrite>>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<TWrite>>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: Extensions.Source.cs
    startLine: 38
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<ValueTask<TWrite>> source, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of ValueTask(Of TWrite)), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of ValueTask(Of TWrite)), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of TWrite)), System.Threading.CancellationToken, System.Boolean)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of ValueTask(Of TWrite)), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Boolean)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Task<TWrite>>, CancellationToken, Boolean)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Task<TWrite>>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TWrite>>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: Extensions.Source.cs
    startLine: 55
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<Task<TWrite>> source, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of Task(Of TWrite)), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Task(Of TWrite)), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of TWrite)), System.Threading.CancellationToken, System.Boolean)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Task(Of TWrite)), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken,System.Boolean)
  id: Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Source<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<TWrite>, CancellationToken, Boolean)
  nameWithType: Extensions.Source<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<TWrite>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Source<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<TWrite>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Source
    path: Extensions.Source.cs
    startLine: 72
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> Source<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<TWrite> source, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{{TWrite}}
      description: The source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Source(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of TWrite), cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.Source*
  nameWithType.vb: Extensions.Source(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of TWrite), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Source(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of TWrite), System.Threading.CancellationToken, System.Boolean)
  name.vb: Source(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of TWrite), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<Func<TWrite>>, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<Func<TWrite>>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Collections.Generic.IEnumerable<System.Func<TWrite>>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: Extensions.Source.cs
    startLine: 89
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nExecutes all entries from the source and passes their result to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, int maxConcurrency, IEnumerable<Func<TWrite>> source, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), maxConcurrency As Integer, source As IEnumerable(Of Func(Of TWrite)), cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of Func(Of TWrite)), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Collections.Generic.IEnumerable(Of System.Func(Of TWrite)), System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of Func(Of TWrite)), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<ValueTask<TWrite>>, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<ValueTask<TWrite>>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<TWrite>>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: Extensions.Source.cs
    startLine: 109
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, int maxConcurrency, IEnumerable<ValueTask<TWrite>> source, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), maxConcurrency As Integer, source As IEnumerable(Of ValueTask(Of TWrite)), cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of ValueTask(Of TWrite)), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of TWrite)), System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of ValueTask(Of TWrite)), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<Task<TWrite>>, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<Task<TWrite>>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TWrite>>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: Extensions.Source.cs
    startLine: 132
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, int maxConcurrency, IEnumerable<Task<TWrite>> source, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), maxConcurrency As Integer, source As IEnumerable(Of Task(Of TWrite)), cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of Task(Of TWrite)), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of TWrite)), System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of Task(Of TWrite)), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Threading.CancellationToken,System.Boolean)
  id: Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Source<T>(Channel<String, T>, TextReader, CancellationToken, Boolean)
  nameWithType: Extensions.Source<T>(Channel<String, T>, TextReader, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Source<T>(System.Threading.Channels.Channel<System.String, T>, System.IO.TextReader, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Source
    path: Extensions.Source.cs
    startLine: 154
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Source<T>(this Channel<string, T> target, TextReader source, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{System.String,{T}}
      description: The channel to write to.
    - id: source
      type: System.IO.TextReader
      description: The source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    typeParameters:
    - id: T
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Source(Of T)(target As Channel(Of String, T), source As TextReader, cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Source*
  nameWithType.vb: Extensions.Source(Of T)(Channel(Of String, T), TextReader, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Source(Of T)(System.Threading.Channels.Channel(Of System.String, T), System.IO.TextReader, System.Threading.CancellationToken, System.Boolean)
  name.vb: Source(Of T)(Channel(Of String, T), TextReader, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.Transform``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1})
  commentId: M:Open.ChannelExtensions.Extensions.Transform``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1})
  id: Transform``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Transform<TIn, TOut>(ChannelReader<TIn>, Func<TIn, TOut>)
  nameWithType: Extensions.Transform<TIn, TOut>(ChannelReader<TIn>, Func<TIn, TOut>)
  fullName: Open.ChannelExtensions.Extensions.Transform<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Func<TIn, TOut>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Transform.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Transform
    path: Extensions.Transform.cs
    startLine: 52
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nTransforms the \n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> Transform<TIn, TOut>(this ChannelReader<TIn> source, Func<TIn, TOut> transform)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel reader.
    - id: transform
      type: System.Func{{TIn},{TOut}}
      description: The transform function.
    typeParameters:
    - id: TIn
      description: The output type of the provided source reader and input type of the transform.
    - id: TOut
      description: The output type of the transform.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: A channel reader representing the tranformed results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Transform(Of TIn, TOut)(source As ChannelReader(Of TIn), transform As Func(Of TIn, TOut)) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.Transform*
  nameWithType.vb: Extensions.Transform(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, TOut))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Transform(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Func(Of TIn, TOut))
  name.vb: Transform(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, TOut))
- uid: Open.ChannelExtensions.Extensions.OfType``2(System.Threading.Channels.ChannelReader{``0})
  commentId: M:Open.ChannelExtensions.Extensions.OfType``2(System.Threading.Channels.ChannelReader{``0})
  id: OfType``2(System.Threading.Channels.ChannelReader{``0})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: OfType<TSource, T>(ChannelReader<TSource>)
  nameWithType: Extensions.OfType<TSource, T>(ChannelReader<TSource>)
  fullName: Open.ChannelExtensions.Extensions.OfType<TSource, T>(System.Threading.Channels.ChannelReader<TSource>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.TypeFilter.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: OfType
    path: Extensions.TypeFilter.cs
    startLine: 49
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nProduces a reader that only contains results of a specific type.  Others are discarded.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> OfType<TSource, T>(this ChannelReader<TSource> source)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TSource}}
      description: The source channel reader.
    typeParameters:
    - id: TSource
      description: The source item type.
    - id: T
      description: The desired item type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader representing the filtered results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function OfType(Of TSource, T)(source As ChannelReader(Of TSource)) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.OfType*
  nameWithType.vb: Extensions.OfType(Of TSource, T)(ChannelReader(Of TSource))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.OfType(Of TSource, T)(System.Threading.Channels.ChannelReader(Of TSource))
  name.vb: OfType(Of TSource, T)(ChannelReader(Of TSource))
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<ValueTask<T>>, Boolean, CancellationToken, Boolean)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<ValueTask<T>>, Boolean, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<T>>, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: Extensions.Write.cs
    startLine: 25
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IEnumerable<ValueTask<T>> source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of ValueTask(Of T)), complete As Boolean = False, cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of ValueTask(Of T)), Boolean, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of T)), System.Boolean, System.Threading.CancellationToken, System.Boolean)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of ValueTask(Of T)), Boolean, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Task<T>>, Boolean, CancellationToken, Boolean)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Task<T>>, Boolean, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<T>>, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: Extensions.Write.cs
    startLine: 58
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IEnumerable<Task<T>> source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of Task(Of T)), complete As Boolean = False, cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Task(Of T)), Boolean, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of T)), System.Boolean, System.Threading.CancellationToken, System.Boolean)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Task(Of T)), Boolean, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Func<T>>, Boolean, CancellationToken, Boolean)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Func<T>>, Boolean, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<System.Func<T>>, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: Extensions.Write.cs
    startLine: 73
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously executes all entries and writes their results to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IEnumerable<Func<T>> source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of Func(Of T)), complete As Boolean = False, cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Func(Of T)), Boolean, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of System.Func(Of T)), System.Boolean, System.Threading.CancellationToken, System.Boolean)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Func(Of T)), Boolean, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  id: WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAll<T>(ChannelWriter<T>, IEnumerable<T>, Boolean, CancellationToken, Boolean)
  nameWithType: Extensions.WriteAll<T>(ChannelWriter<T>, IEnumerable<T>, Boolean, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.WriteAll<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<T>, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAll
    path: Extensions.Write.cs
    startLine: 88
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAll<T>(this ChannelWriter<T> target, IEnumerable<T> source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{{T}}
      description: The source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAll(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of T), complete As Boolean = False, cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAll*
  nameWithType.vb: Extensions.WriteAll(Of T)(ChannelWriter(Of T), IEnumerable(Of T), Boolean, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAll(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of T), System.Boolean, System.Threading.CancellationToken, System.Boolean)
  name.vb: WriteAll(Of T)(ChannelWriter(Of T), IEnumerable(Of T), Boolean, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  id: WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllLines(ChannelWriter<String>, TextReader, Boolean, CancellationToken, Boolean)
  nameWithType: Extensions.WriteAllLines(ChannelWriter<String>, TextReader, Boolean, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter<System.String>, System.IO.TextReader, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllLines
    path: Extensions.Write.cs
    startLine: 102
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nConsumes all lines from a TextReader and writes them to a channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllLines(this ChannelWriter<string> target, TextReader source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{System.String}
      description: The channel to write to.
    - id: source
      type: System.IO.TextReader
      description: The text reader to consume from.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllLines(target As ChannelWriter(Of String), source As TextReader, complete As Boolean = False, cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllLines*
  nameWithType.vb: Extensions.WriteAllLines(ChannelWriter(Of String), TextReader, Boolean, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter(Of System.String), System.IO.TextReader, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  name.vb: WriteAllLines(ChannelWriter(Of String), TextReader, Boolean, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  id: WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<ValueTask<T>>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<ValueTask<T>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Int32, System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<T>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.WriteConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllConcurrentlyAsync
    path: Extensions.WriteConcurrently.cs
    startLine: 23
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static Task<long> WriteAllConcurrentlyAsync<T>(this ChannelWriter<T> target, int maxConcurrency, IEnumerable<ValueTask<T>> source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllConcurrentlyAsync(Of T)(target As ChannelWriter(Of T), maxConcurrency As Integer, source As IEnumerable(Of ValueTask(Of T)), complete As Boolean = False, cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync*
  nameWithType.vb: Extensions.WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of ValueTask(Of T)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Int32, System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of T)), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of ValueTask(Of T)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  id: WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<Task<T>>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<Task<T>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Int32, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<T>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.WriteConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllConcurrentlyAsync
    path: Extensions.WriteConcurrently.cs
    startLine: 110
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static Task<long> WriteAllConcurrentlyAsync<T>(this ChannelWriter<T> target, int maxConcurrency, IEnumerable<Task<T>> source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllConcurrentlyAsync(Of T)(target As ChannelWriter(Of T), maxConcurrency As Integer, source As IEnumerable(Of Task(Of T)), complete As Boolean = False, cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync*
  nameWithType.vb: Extensions.WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of Task(Of T)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Int32, System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of T)), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of Task(Of T)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  id: WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<Func<T>>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<Func<T>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Int32, System.Collections.Generic.IEnumerable<System.Func<T>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.WriteConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllConcurrentlyAsync
    path: Extensions.WriteConcurrently.cs
    startLine: 125
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously executes all entries and writes their results to the channel.\n"
  example: []
  syntax:
    content: public static Task<long> WriteAllConcurrentlyAsync<T>(this ChannelWriter<T> target, int maxConcurrency, IEnumerable<Func<T>> source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllConcurrentlyAsync(Of T)(target As ChannelWriter(Of T), maxConcurrency As Integer, source As IEnumerable(Of Func(Of T)), complete As Boolean = False, cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync*
  nameWithType.vb: Extensions.WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of Func(Of T)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Int32, System.Collections.Generic.IEnumerable(Of System.Func(Of T)), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of Func(Of T)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Threading.CancellationToken)
  id: WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, String, CancellationToken)
  nameWithType: Extensions.WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, String, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.String, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WaitToWriteAndThrowIfClosedAsync
    path: Extensions._.cs
    startLine: 49
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWaits for opportunity to write to a channel and throws a ChannelClosedException if the channel is closed.  \n"
  example: []
  syntax:
    content: public static ValueTask WaitToWriteAndThrowIfClosedAsync<T>(this ChannelWriter<T> writer, string ifClosedMessage, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: writer
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel writer.
    - id: ifClosedMessage
      type: System.String
      description: The message to include with the ChannelClosedException if thrown.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The type being written to the channel
    return:
      type: System.Threading.Tasks.ValueTask
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WaitToWriteAndThrowIfClosedAsync(Of T)(writer As ChannelWriter(Of T), ifClosedMessage As String, cancellationToken As CancellationToken = Nothing) As ValueTask
  overload: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync*
  nameWithType.vb: Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), String, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.String, System.Threading.CancellationToken)
  name.vb: WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), String, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Boolean,System.Threading.CancellationToken)
  id: WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, String, Boolean, CancellationToken)
  nameWithType: Extensions.WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, String, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.String, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WaitToWriteAndThrowIfClosedAsync
    path: Extensions._.cs
    startLine: 72
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWaits for opportunity to write to a channel and throws a ChannelClosedException if the channel is closed.  \n"
  example: []
  syntax:
    content: public static ValueTask WaitToWriteAndThrowIfClosedAsync<T>(this ChannelWriter<T> writer, string ifClosedMessage, bool deferredExecution, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: writer
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel writer.
    - id: ifClosedMessage
      type: System.String
      description: The message to include with the ChannelClosedException if thrown.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before continuing.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The type being written to the channel
    return:
      type: System.Threading.Tasks.ValueTask
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WaitToWriteAndThrowIfClosedAsync(Of T)(writer As ChannelWriter(Of T), ifClosedMessage As String, deferredExecution As Boolean, cancellationToken As CancellationToken = Nothing) As ValueTask
  overload: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync*
  nameWithType.vb: Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), String, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.String, System.Boolean, System.Threading.CancellationToken)
  name.vb: WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), String, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Threading.CancellationToken)
  id: WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, CancellationToken)
  nameWithType: Extensions.WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WaitToWriteAndThrowIfClosedAsync
    path: Extensions._.cs
    startLine: 92
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWaits for opportunity to write to a channel and throws a ChannelClosedException if the channel is closed.  \n"
  example: []
  syntax:
    content: public static ValueTask WaitToWriteAndThrowIfClosedAsync<T>(this ChannelWriter<T> writer, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: writer
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel writer.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The type being written to the channel
    return:
      type: System.Threading.Tasks.ValueTask
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WaitToWriteAndThrowIfClosedAsync(Of T)(writer As ChannelWriter(Of T), cancellationToken As CancellationToken = Nothing) As ValueTask
  overload: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync*
  nameWithType.vb: Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Threading.CancellationToken)
  name.vb: WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  id: WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, Boolean, CancellationToken)
  nameWithType: Extensions.WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WaitToWriteAndThrowIfClosedAsync
    path: Extensions._.cs
    startLine: 114
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWaits for opportunity to write to a channel and throws a ChannelClosedException if the channel is closed.  \n"
  example: []
  syntax:
    content: public static ValueTask WaitToWriteAndThrowIfClosedAsync<T>(this ChannelWriter<T> writer, bool deferredExecution, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: writer
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel writer.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before continuing.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The type being written to the channel
    return:
      type: System.Threading.Tasks.ValueTask
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WaitToWriteAndThrowIfClosedAsync(Of T)(writer As ChannelWriter(Of T), deferredExecution As Boolean, cancellationToken As CancellationToken = Nothing) As ValueTask
  overload: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync*
  nameWithType.vb: Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Boolean, System.Threading.CancellationToken)
  name.vb: WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.CompleteAsync``2(System.Threading.Channels.Channel{``0,``1},System.Exception)
  commentId: M:Open.ChannelExtensions.Extensions.CompleteAsync``2(System.Threading.Channels.Channel{``0,``1},System.Exception)
  id: CompleteAsync``2(System.Threading.Channels.Channel{``0,``1},System.Exception)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: CompleteAsync<TWrite, TRead>(Channel<TWrite, TRead>, Exception)
  nameWithType: Extensions.CompleteAsync<TWrite, TRead>(Channel<TWrite, TRead>, Exception)
  fullName: Open.ChannelExtensions.Extensions.CompleteAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Exception)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: CompleteAsync
    path: Extensions._.cs
    startLine: 136
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nCalls complete on the writer and returns the completion from the reader.\n"
  example: []
  syntax:
    content: public static Task CompleteAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Exception exception = null)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to complete asynchronously.
    - id: exception
      type: System.Exception
      description: The optional exception to include with completion.
    typeParameters:
    - id: TWrite
      description: The type being received by the writer.
    - id: TRead
      description: The type being read from the reader.
    return:
      type: System.Threading.Tasks.Task
      description: The reader&apos;s completion task.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function CompleteAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), exception As Exception = Nothing) As Task
  overload: Open.ChannelExtensions.Extensions.CompleteAsync*
  nameWithType.vb: Extensions.CompleteAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Exception)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.CompleteAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Exception)
  name.vb: CompleteAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Exception)
- uid: Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  id: ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannel(TextReader, Int32, Boolean, CancellationToken, Boolean)
  nameWithType: Extensions.ToChannel(TextReader, Int32, Boolean, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader, System.Int32, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannel
    path: Extensions._.cs
    startLine: 151
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all lines from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<string> ToChannel(this TextReader source, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: source
      type: System.IO.TextReader
      description: The source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    return:
      type: System.Threading.Channels.ChannelReader{System.String}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannel(source As TextReader, capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ChannelReader(Of String)
  overload: Open.ChannelExtensions.Extensions.ToChannel*
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  id: ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannel<T>(IEnumerable<T>, Int32, Boolean, CancellationToken, Boolean)
  nameWithType: Extensions.ToChannel<T>(IEnumerable<T>, Int32, Boolean, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ToChannel<T>(System.Collections.Generic.IEnumerable<T>, System.Int32, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannel
    path: Extensions._.cs
    startLine: 168
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannel<T>(this IEnumerable<T> source, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken), bool deferredExecution = false)
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{{T}}
      description: The source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannel(Of T)(source As IEnumerable(Of T), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing, deferredExecution As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannel*
  nameWithType.vb: Extensions.ToChannel(Of T)(IEnumerable(Of T), Int32, Boolean, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannel(Of T)(System.Collections.Generic.IEnumerable(Of T), System.Int32, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  name.vb: ToChannel(Of T)(IEnumerable(Of T), Int32, Boolean, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  id: ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannelAsync<T>(IEnumerable<Func<T>>, Int32, Boolean, Int32, CancellationToken)
  nameWithType: Extensions.ToChannelAsync<T>(IEnumerable<Func<T>>, Int32, Boolean, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync<T>(System.Collections.Generic.IEnumerable<System.Func<T>>, System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannelAsync
    path: Extensions._.cs
    startLine: 204
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously executes all entries and writes their results to a channel.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannelAsync<T>(this IEnumerable<Func<T>> source, int capacity = -1, bool singleReader = false, int maxConcurrency = 1, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{T}}}
      description: The asynchronous source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannelAsync(Of T)(source As IEnumerable(Of Func(Of T)), capacity As Integer = -1, singleReader As Boolean = False, maxConcurrency As Integer = 1, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannelAsync*
  nameWithType.vb: Extensions.ToChannelAsync(Of T)(IEnumerable(Of Func(Of T)), Int32, Boolean, Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannelAsync(Of T)(System.Collections.Generic.IEnumerable(Of System.Func(Of T)), System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  name.vb: ToChannelAsync(Of T)(IEnumerable(Of Func(Of T)), Int32, Boolean, Int32, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  id: ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannelAsync<T>(IEnumerable<ValueTask<T>>, Int32, Boolean, Int32, CancellationToken)
  nameWithType: Extensions.ToChannelAsync<T>(IEnumerable<ValueTask<T>>, Int32, Boolean, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync<T>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<T>>, System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannelAsync
    path: Extensions._.cs
    startLine: 220
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannelAsync<T>(this IEnumerable<ValueTask<T>> source, int capacity = -1, bool singleReader = false, int maxConcurrency = 1, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{T}}}
      description: The asynchronous source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannelAsync(Of T)(source As IEnumerable(Of ValueTask(Of T)), capacity As Integer = -1, singleReader As Boolean = False, maxConcurrency As Integer = 1, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannelAsync*
  nameWithType.vb: Extensions.ToChannelAsync(Of T)(IEnumerable(Of ValueTask(Of T)), Int32, Boolean, Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannelAsync(Of T)(System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of T)), System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  name.vb: ToChannelAsync(Of T)(IEnumerable(Of ValueTask(Of T)), Int32, Boolean, Int32, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  id: ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannelAsync<T>(IEnumerable<Task<T>>, Int32, Boolean, Int32, CancellationToken)
  nameWithType: Extensions.ToChannelAsync<T>(IEnumerable<Task<T>>, Int32, Boolean, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync<T>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<T>>, System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannelAsync
    path: Extensions._.cs
    startLine: 236
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannelAsync<T>(this IEnumerable<Task<T>> source, int capacity = -1, bool singleReader = false, int maxConcurrency = 1, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{T}}}
      description: The asynchronous source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannelAsync(Of T)(source As IEnumerable(Of Task(Of T)), capacity As Integer = -1, singleReader As Boolean = False, maxConcurrency As Integer = 1, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannelAsync*
  nameWithType.vb: Extensions.ToChannelAsync(Of T)(IEnumerable(Of Task(Of T)), Int32, Boolean, Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannelAsync(Of T)(System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of T)), System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  name.vb: ToChannelAsync(Of T)(IEnumerable(Of Task(Of T)), Int32, Boolean, Int32, CancellationToken)
references:
- uid: Open.ChannelExtensions
  commentId: N:Open.ChannelExtensions
  name: Open.ChannelExtensions
  nameWithType: Open.ChannelExtensions
  fullName: Open.ChannelExtensions
- uid: System.Object
  commentId: T:System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Object.Equals(System.Object)
  commentId: M:System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  nameWithType: Object.Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  commentId: M:System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  nameWithType: Object.Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.GetHashCode
  commentId: M:System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  nameWithType: Object.GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.GetType
  commentId: M:System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  nameWithType: Object.GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.MemberwiseClone
  commentId: M:System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  nameWithType: Object.MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  nameWithType: Object.ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.ToString
  commentId: M:System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  nameWithType: Object.ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System
  commentId: N:System
  isExternal: true
  name: System
  nameWithType: System
  fullName: System
- uid: Open.ChannelExtensions.Extensions.Batch*
  commentId: Overload:Open.ChannelExtensions.Extensions.Batch
  name: Batch
  nameWithType: Extensions.Batch
  fullName: Open.ChannelExtensions.Extensions.Batch
- uid: System.Threading.Channels.ChannelReader{{T}}
  commentId: T:System.Threading.Channels.ChannelReader{``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<T>
  nameWithType: ChannelReader<T>
  fullName: System.Threading.Channels.ChannelReader<T>
  nameWithType.vb: ChannelReader(Of T)
  fullName.vb: System.Threading.Channels.ChannelReader(Of T)
  name.vb: ChannelReader(Of T)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Int32
  commentId: T:System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  commentId: T:System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Channels.ChannelReader{System.Collections.Generic.List{{T}}}
  commentId: T:System.Threading.Channels.ChannelReader{System.Collections.Generic.List{``0}}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<List<T>>
  nameWithType: ChannelReader<List<T>>
  fullName: System.Threading.Channels.ChannelReader<System.Collections.Generic.List<T>>
  nameWithType.vb: ChannelReader(Of List(Of T))
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.Collections.Generic.List(Of T))
  name.vb: ChannelReader(Of List(Of T))
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader`1
  commentId: T:System.Threading.Channels.ChannelReader`1
  isExternal: true
  name: ChannelReader<T>
  nameWithType: ChannelReader<T>
  fullName: System.Threading.Channels.ChannelReader<T>
  nameWithType.vb: ChannelReader(Of T)
  fullName.vb: System.Threading.Channels.ChannelReader(Of T)
  name.vb: ChannelReader(Of T)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels
  commentId: N:System.Threading.Channels
  isExternal: true
  name: System.Threading.Channels
  nameWithType: System.Threading.Channels
  fullName: System.Threading.Channels
- uid: Open.ChannelExtensions.Extensions.Filter*
  commentId: Overload:Open.ChannelExtensions.Extensions.Filter
  name: Filter
  nameWithType: Extensions.Filter
  fullName: Open.ChannelExtensions.Extensions.Filter
- uid: System.Func{{T},System.Boolean}
  commentId: T:System.Func{``0,System.Boolean}
  parent: System
  definition: System.Func`2
  name: Func<T, Boolean>
  nameWithType: Func<T, Boolean>
  fullName: System.Func<T, System.Boolean>
  nameWithType.vb: Func(Of T, Boolean)
  fullName.vb: System.Func(Of T, System.Boolean)
  name.vb: Func(Of T, Boolean)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func`2
  commentId: T:System.Func`2
  isExternal: true
  name: Func<T, TResult>
  nameWithType: Func<T, TResult>
  fullName: System.Func<T, TResult>
  nameWithType.vb: Func(Of T, TResult)
  fullName.vb: System.Func(Of T, TResult)
  name.vb: Func(Of T, TResult)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.Join*
  commentId: Overload:Open.ChannelExtensions.Extensions.Join
  name: Join
  nameWithType: Extensions.Join
  fullName: Open.ChannelExtensions.Extensions.Join
- uid: System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{{T}}}
  commentId: T:System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{``0}}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<IEnumerable<T>>
  nameWithType: ChannelReader<IEnumerable<T>>
  fullName: System.Threading.Channels.ChannelReader<System.Collections.Generic.IEnumerable<T>>
  nameWithType.vb: ChannelReader(Of IEnumerable(Of T))
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.Collections.Generic.IEnumerable(Of T))
  name.vb: ChannelReader(Of IEnumerable(Of T))
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{{T}}}
  commentId: T:System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{``0}}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<ICollection<T>>
  nameWithType: ChannelReader<ICollection<T>>
  fullName: System.Threading.Channels.ChannelReader<System.Collections.Generic.ICollection<T>>
  nameWithType.vb: ChannelReader(Of ICollection(Of T))
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.Collections.Generic.ICollection(Of T))
  name.vb: ChannelReader(Of ICollection(Of T))
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.ICollection`1
    name: ICollection
    nameWithType: ICollection
    fullName: System.Collections.Generic.ICollection
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.ICollection`1
    name: ICollection
    nameWithType: ICollection
    fullName: System.Collections.Generic.ICollection
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{{T}}}
  commentId: T:System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{``0}}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<IList<T>>
  nameWithType: ChannelReader<IList<T>>
  fullName: System.Threading.Channels.ChannelReader<System.Collections.Generic.IList<T>>
  nameWithType.vb: ChannelReader(Of IList(Of T))
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.Collections.Generic.IList(Of T))
  name.vb: ChannelReader(Of IList(Of T))
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: System.Collections.Generic.IList
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: System.Collections.Generic.IList
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{{T}[]}
  commentId: T:System.Threading.Channels.ChannelReader{``0[]}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<T[]>
  nameWithType: ChannelReader<T[]>
  fullName: System.Threading.Channels.ChannelReader<T[]>
  nameWithType.vb: ChannelReader(Of T())
  fullName.vb: System.Threading.Channels.ChannelReader(Of T())
  name.vb: ChannelReader(Of T())
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ()
    nameWithType: ()
    fullName: ()
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.PipeAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.PipeAsync
  name: PipeAsync
  nameWithType: Extensions.PipeAsync
  fullName: Open.ChannelExtensions.Extensions.PipeAsync
- uid: System.Threading.Channels.ChannelReader{{TIn}}
  commentId: T:System.Threading.Channels.ChannelReader{``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<TIn>
  nameWithType: ChannelReader<TIn>
  fullName: System.Threading.Channels.ChannelReader<TIn>
  nameWithType.vb: ChannelReader(Of TIn)
  fullName.vb: System.Threading.Channels.ChannelReader(Of TIn)
  name.vb: ChannelReader(Of TIn)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TIn},System.Threading.Tasks.ValueTask{{TOut}}}
  commentId: T:System.Func{``0,System.Threading.Tasks.ValueTask{``1}}
  parent: System
  definition: System.Func`2
  name: Func<TIn, ValueTask<TOut>>
  nameWithType: Func<TIn, ValueTask<TOut>>
  fullName: System.Func<TIn, System.Threading.Tasks.ValueTask<TOut>>
  nameWithType.vb: Func(Of TIn, ValueTask(Of TOut))
  fullName.vb: System.Func(Of TIn, System.Threading.Tasks.ValueTask(Of TOut))
  name.vb: Func(Of TIn, ValueTask(Of TOut))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.CancellationToken
  commentId: T:System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Threading.Channels.ChannelReader{{TOut}}
  commentId: T:System.Threading.Channels.ChannelReader{``1}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<TOut>
  nameWithType: ChannelReader<TOut>
  fullName: System.Threading.Channels.ChannelReader<TOut>
  nameWithType.vb: ChannelReader(Of TOut)
  fullName.vb: System.Threading.Channels.ChannelReader(Of TOut)
  name.vb: ChannelReader(Of TOut)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading
  commentId: N:System.Threading
  isExternal: true
  name: System.Threading
  nameWithType: System.Threading
  fullName: System.Threading
- uid: System.Threading.Channels.Channel{{TWrite},{TRead}}
  commentId: T:System.Threading.Channels.Channel{``0,``1}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.Channel`2
  name: Channel<TWrite, TRead>
  nameWithType: Channel<TWrite, TRead>
  fullName: System.Threading.Channels.Channel<TWrite, TRead>
  nameWithType.vb: Channel(Of TWrite, TRead)
  fullName.vb: System.Threading.Channels.Channel(Of TWrite, TRead)
  name.vb: Channel(Of TWrite, TRead)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},System.Threading.Tasks.ValueTask{{TOut}}}
  commentId: T:System.Func{``1,System.Threading.Tasks.ValueTask{``2}}
  parent: System
  definition: System.Func`2
  name: Func<TRead, ValueTask<TOut>>
  nameWithType: Func<TRead, ValueTask<TOut>>
  fullName: System.Func<TRead, System.Threading.Tasks.ValueTask<TOut>>
  nameWithType.vb: Func(Of TRead, ValueTask(Of TOut))
  fullName.vb: System.Func(Of TRead, System.Threading.Tasks.ValueTask(Of TOut))
  name.vb: Func(Of TRead, ValueTask(Of TOut))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.Channel`2
  commentId: T:System.Threading.Channels.Channel`2
  isExternal: true
  name: Channel<TWrite, TRead>
  nameWithType: Channel<TWrite, TRead>
  fullName: System.Threading.Channels.Channel<TWrite, TRead>
  nameWithType.vb: Channel(Of TWrite, TRead)
  fullName.vb: System.Threading.Channels.Channel(Of TWrite, TRead)
  name.vb: Channel(Of TWrite, TRead)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.TaskPipeAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.TaskPipeAsync
  name: TaskPipeAsync
  nameWithType: Extensions.TaskPipeAsync
  fullName: Open.ChannelExtensions.Extensions.TaskPipeAsync
- uid: System.Func{{TIn},System.Threading.Tasks.Task{{TOut}}}
  commentId: T:System.Func{``0,System.Threading.Tasks.Task{``1}}
  parent: System
  definition: System.Func`2
  name: Func<TIn, Task<TOut>>
  nameWithType: Func<TIn, Task<TOut>>
  fullName: System.Func<TIn, System.Threading.Tasks.Task<TOut>>
  nameWithType.vb: Func(Of TIn, Task(Of TOut))
  fullName.vb: System.Func(Of TIn, System.Threading.Tasks.Task(Of TOut))
  name.vb: Func(Of TIn, Task(Of TOut))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},System.Threading.Tasks.Task{{TOut}}}
  commentId: T:System.Func{``1,System.Threading.Tasks.Task{``2}}
  parent: System
  definition: System.Func`2
  name: Func<TRead, Task<TOut>>
  nameWithType: Func<TRead, Task<TOut>>
  fullName: System.Func<TRead, System.Threading.Tasks.Task<TOut>>
  nameWithType.vb: Func(Of TRead, Task(Of TOut))
  fullName.vb: System.Func(Of TRead, System.Threading.Tasks.Task(Of TOut))
  name.vb: Func(Of TRead, Task(Of TOut))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.Pipe*
  commentId: Overload:Open.ChannelExtensions.Extensions.Pipe
  name: Pipe
  nameWithType: Extensions.Pipe
  fullName: Open.ChannelExtensions.Extensions.Pipe
- uid: System.Func{{TIn},{TOut}}
  commentId: T:System.Func{``0,``1}
  parent: System
  definition: System.Func`2
  name: Func<TIn, TOut>
  nameWithType: Func<TIn, TOut>
  fullName: System.Func<TIn, TOut>
  nameWithType.vb: Func(Of TIn, TOut)
  fullName.vb: System.Func(Of TIn, TOut)
  name.vb: Func(Of TIn, TOut)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},{TOut}}
  commentId: T:System.Func{``1,``2}
  parent: System
  definition: System.Func`2
  name: Func<TRead, TOut>
  nameWithType: Func<TRead, TOut>
  fullName: System.Func<TRead, TOut>
  nameWithType.vb: Func(Of TRead, TOut)
  fullName.vb: System.Func(Of TRead, TOut)
  name.vb: Func(Of TRead, TOut)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ReadAvailable*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAvailable
  name: ReadAvailable
  nameWithType: Extensions.ReadAvailable
  fullName: Open.ChannelExtensions.Extensions.ReadAvailable
- uid: System.Collections.Generic.IEnumerable{{T}}
  commentId: T:System.Collections.Generic.IEnumerable{``0}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<T>
  nameWithType: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  nameWithType.vb: IEnumerable(Of T)
  fullName.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable`1
  commentId: T:System.Collections.Generic.IEnumerable`1
  isExternal: true
  name: IEnumerable<T>
  nameWithType: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  nameWithType.vb: IEnumerable(Of T)
  fullName.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic
  commentId: N:System.Collections.Generic
  isExternal: true
  name: System.Collections.Generic
  nameWithType: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: Open.ChannelExtensions.Extensions.ReadBatchAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadBatchAsync
  name: ReadBatchAsync
  nameWithType: Extensions.ReadBatchAsync
  fullName: Open.ChannelExtensions.Extensions.ReadBatchAsync
- uid: System.Threading.Tasks.ValueTask{System.Collections.Generic.List{{T}}}
  commentId: T:System.Threading.Tasks.ValueTask{System.Collections.Generic.List{``0}}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.ValueTask`1
  name: ValueTask<List<T>>
  nameWithType: ValueTask<List<T>>
  fullName: System.Threading.Tasks.ValueTask<System.Collections.Generic.List<T>>
  nameWithType.vb: ValueTask(Of List(Of T))
  fullName.vb: System.Threading.Tasks.ValueTask(Of System.Collections.Generic.List(Of T))
  name.vb: ValueTask(Of List(Of T))
  spec.csharp:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Tasks.ValueTask`1
  commentId: T:System.Threading.Tasks.ValueTask`1
  isExternal: true
  name: ValueTask<TResult>
  nameWithType: ValueTask<TResult>
  fullName: System.Threading.Tasks.ValueTask<TResult>
  nameWithType.vb: ValueTask(Of TResult)
  fullName.vb: System.Threading.Tasks.ValueTask(Of TResult)
  name.vb: ValueTask(Of TResult)
  spec.csharp:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Tasks
  commentId: N:System.Threading.Tasks
  isExternal: true
  name: System.Threading.Tasks
  nameWithType: System.Threading.Tasks
  fullName: System.Threading.Tasks
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync
  name: ReadUntilCancelledAsync
  nameWithType: Extensions.ReadUntilCancelledAsync
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync
- uid: System.Func{{T},System.Int64,System.Threading.Tasks.ValueTask}
  commentId: T:System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask}
  parent: System
  definition: System.Func`3
  name: Func<T, Int64, ValueTask>
  nameWithType: Func<T, Int64, ValueTask>
  fullName: System.Func<T, System.Int64, System.Threading.Tasks.ValueTask>
  nameWithType.vb: Func(Of T, Int64, ValueTask)
  fullName.vb: System.Func(Of T, System.Int64, System.Threading.Tasks.ValueTask)
  name.vb: Func(Of T, Int64, ValueTask)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Tasks.ValueTask{System.Int64}
  commentId: T:System.Threading.Tasks.ValueTask{System.Int64}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.ValueTask`1
  name: ValueTask<Int64>
  nameWithType: ValueTask<Int64>
  fullName: System.Threading.Tasks.ValueTask<System.Int64>
  nameWithType.vb: ValueTask(Of Int64)
  fullName.vb: System.Threading.Tasks.ValueTask(Of System.Int64)
  name.vb: ValueTask(Of Int64)
  spec.csharp:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func`3
  commentId: T:System.Func`3
  isExternal: true
  name: Func<T1, T2, TResult>
  nameWithType: Func<T1, T2, TResult>
  fullName: System.Func<T1, T2, TResult>
  nameWithType.vb: Func(Of T1, T2, TResult)
  fullName.vb: System.Func(Of T1, T2, TResult)
  name.vb: Func(Of T1, T2, TResult)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},System.Int64,System.Threading.Tasks.ValueTask}
  commentId: T:System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask}
  parent: System
  definition: System.Func`3
  name: Func<TRead, Int64, ValueTask>
  nameWithType: Func<TRead, Int64, ValueTask>
  fullName: System.Func<TRead, System.Int64, System.Threading.Tasks.ValueTask>
  nameWithType.vb: Func(Of TRead, Int64, ValueTask)
  fullName.vb: System.Func(Of TRead, System.Int64, System.Threading.Tasks.ValueTask)
  name.vb: Func(Of TRead, Int64, ValueTask)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{T},System.Threading.Tasks.ValueTask}
  commentId: T:System.Func{``0,System.Threading.Tasks.ValueTask}
  parent: System
  definition: System.Func`2
  name: Func<T, ValueTask>
  nameWithType: Func<T, ValueTask>
  fullName: System.Func<T, System.Threading.Tasks.ValueTask>
  nameWithType.vb: Func(Of T, ValueTask)
  fullName.vb: System.Func(Of T, System.Threading.Tasks.ValueTask)
  name.vb: Func(Of T, ValueTask)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},System.Threading.Tasks.ValueTask}
  commentId: T:System.Func{``1,System.Threading.Tasks.ValueTask}
  parent: System
  definition: System.Func`2
  name: Func<TRead, ValueTask>
  nameWithType: Func<TRead, ValueTask>
  fullName: System.Func<TRead, System.Threading.Tasks.ValueTask>
  nameWithType.vb: Func(Of TRead, ValueTask)
  fullName.vb: System.Func(Of TRead, System.Threading.Tasks.ValueTask)
  name.vb: Func(Of TRead, ValueTask)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelled*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadUntilCancelled
  name: ReadUntilCancelled
  nameWithType: Extensions.ReadUntilCancelled
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelled
- uid: System.Action{{T},System.Int64}
  commentId: T:System.Action{``0,System.Int64}
  parent: System
  definition: System.Action`2
  name: Action<T, Int64>
  nameWithType: Action<T, Int64>
  fullName: System.Action<T, System.Int64>
  nameWithType.vb: Action(Of T, Int64)
  fullName.vb: System.Action(Of T, System.Int64)
  name.vb: Action(Of T, Int64)
  spec.csharp:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Action`2
  commentId: T:System.Action`2
  isExternal: true
  name: Action<T1, T2>
  nameWithType: Action<T1, T2>
  fullName: System.Action<T1, T2>
  nameWithType.vb: Action(Of T1, T2)
  fullName.vb: System.Action(Of T1, T2)
  name.vb: Action(Of T1, T2)
  spec.csharp:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Action{{TRead},System.Int64}
  commentId: T:System.Action{``1,System.Int64}
  parent: System
  definition: System.Action`2
  name: Action<TRead, Int64>
  nameWithType: Action<TRead, Int64>
  fullName: System.Action<TRead, System.Int64>
  nameWithType.vb: Action(Of TRead, Int64)
  fullName.vb: System.Action(Of TRead, System.Int64)
  name.vb: Action(Of TRead, Int64)
  spec.csharp:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Action{{T}}
  commentId: T:System.Action{``0}
  parent: System
  definition: System.Action`1
  name: Action<T>
  nameWithType: Action<T>
  fullName: System.Action<T>
  nameWithType.vb: Action(Of T)
  fullName.vb: System.Action(Of T)
  name.vb: Action(Of T)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Action`1
  commentId: T:System.Action`1
  isExternal: true
  name: Action<T>
  nameWithType: Action<T>
  fullName: System.Action<T>
  nameWithType.vb: Action(Of T)
  fullName.vb: System.Action(Of T)
  name.vb: Action(Of T)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Action{{TRead}}
  commentId: T:System.Action{``1}
  parent: System
  definition: System.Action`1
  name: Action<TRead>
  nameWithType: Action<TRead>
  fullName: System.Action<TRead>
  nameWithType.vb: Action(Of TRead)
  fullName.vb: System.Action(Of TRead)
  name.vb: Action(Of TRead)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAllAsync
  name: ReadAllAsync
  nameWithType: Extensions.ReadAllAsync
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.TaskReadAllAsync
  name: TaskReadAllAsync
  nameWithType: Extensions.TaskReadAllAsync
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync
- uid: System.Func{{TRead},System.Int64,System.Threading.Tasks.Task}
  commentId: T:System.Func{``1,System.Int64,System.Threading.Tasks.Task}
  parent: System
  definition: System.Func`3
  name: Func<TRead, Int64, Task>
  nameWithType: Func<TRead, Int64, Task>
  fullName: System.Func<TRead, System.Int64, System.Threading.Tasks.Task>
  nameWithType.vb: Func(Of TRead, Int64, Task)
  fullName.vb: System.Func(Of TRead, System.Int64, System.Threading.Tasks.Task)
  name.vb: Func(Of TRead, Int64, Task)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{T},System.Threading.Tasks.Task}
  commentId: T:System.Func{``0,System.Threading.Tasks.Task}
  parent: System
  definition: System.Func`2
  name: Func<T, Task>
  nameWithType: Func<T, Task>
  fullName: System.Func<T, System.Threading.Tasks.Task>
  nameWithType.vb: Func(Of T, Task)
  fullName.vb: System.Func(Of T, System.Threading.Tasks.Task)
  name.vb: Func(Of T, Task)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},System.Threading.Tasks.Task}
  commentId: T:System.Func{``1,System.Threading.Tasks.Task}
  parent: System
  definition: System.Func`2
  name: Func<TRead, Task>
  nameWithType: Func<TRead, Task>
  fullName: System.Func<TRead, System.Threading.Tasks.Task>
  nameWithType.vb: Func(Of TRead, Task)
  fullName.vb: System.Func(Of TRead, System.Threading.Tasks.Task)
  name.vb: Func(Of TRead, Task)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ReadAll*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAll
  name: ReadAll
  nameWithType: Extensions.ReadAll
  fullName: Open.ChannelExtensions.Extensions.ReadAll
- uid: Open.ChannelExtensions.Extensions.ReadAllAsLines*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAllAsLines
  name: ReadAllAsLines
  nameWithType: Extensions.ReadAllAsLines
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsLines
- uid: System.Threading.Channels.ChannelReader{System.String}
  commentId: T:System.Threading.Channels.ChannelReader{System.String}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<String>
  nameWithType: ChannelReader<String>
  fullName: System.Threading.Channels.ChannelReader<System.String>
  nameWithType.vb: ChannelReader(Of String)
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.String)
  name.vb: ChannelReader(Of String)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.IO.TextWriter
  commentId: T:System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.IO
  commentId: N:System.IO
  isExternal: true
  name: System.IO
  nameWithType: System.IO
  fullName: System.IO
- uid: System.Threading.Channels.Channel{{T},System.String}
  commentId: T:System.Threading.Channels.Channel{``0,System.String}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.Channel`2
  name: Channel<T, String>
  nameWithType: Channel<T, String>
  fullName: System.Threading.Channels.Channel<T, System.String>
  nameWithType.vb: Channel(Of T, String)
  fullName.vb: System.Threading.Channels.Channel(Of T, System.String)
  name.vb: Channel(Of T, String)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync
  name: ReadAllConcurrentlyAsync
  nameWithType: Extensions.ReadAllConcurrentlyAsync
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync
- uid: System.Threading.Tasks.Task{System.Int64}
  commentId: T:System.Threading.Tasks.Task{System.Int64}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<Int64>
  nameWithType: Task<Int64>
  fullName: System.Threading.Tasks.Task<System.Int64>
  nameWithType.vb: Task(Of Int64)
  fullName.vb: System.Threading.Tasks.Task(Of System.Int64)
  name.vb: Task(Of Int64)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Tasks.Task`1
  commentId: T:System.Threading.Tasks.Task`1
  isExternal: true
  name: Task<TResult>
  nameWithType: Task<TResult>
  fullName: System.Threading.Tasks.Task<TResult>
  nameWithType.vb: Task(Of TResult)
  fullName.vb: System.Threading.Tasks.Task(Of TResult)
  name.vb: Task(Of TResult)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync
  name: TaskReadAllConcurrentlyAsync
  nameWithType: Extensions.TaskReadAllConcurrentlyAsync
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrently*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAllConcurrently
  name: ReadAllConcurrently
  nameWithType: Extensions.ReadAllConcurrently
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrently
- uid: Open.ChannelExtensions.Extensions.SourceAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.SourceAsync
  name: SourceAsync
  nameWithType: Extensions.SourceAsync
  fullName: Open.ChannelExtensions.Extensions.SourceAsync
- uid: System.Collections.Generic.IEnumerable{System.Func{{TWrite}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Func{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Func<TWrite>>
  nameWithType: IEnumerable<Func<TWrite>>
  fullName: System.Collections.Generic.IEnumerable<System.Func<TWrite>>
  nameWithType.vb: IEnumerable(Of Func(Of TWrite))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Func(Of TWrite))
  name.vb: IEnumerable(Of Func(Of TWrite))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{{TRead}}
  commentId: T:System.Threading.Channels.ChannelReader{``1}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<TRead>
  nameWithType: ChannelReader<TRead>
  fullName: System.Threading.Channels.ChannelReader<TRead>
  nameWithType.vb: ChannelReader(Of TRead)
  fullName.vb: System.Threading.Channels.ChannelReader(Of TRead)
  name.vb: ChannelReader(Of TRead)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{TWrite}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<ValueTask<TWrite>>
  nameWithType: IEnumerable<ValueTask<TWrite>>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<TWrite>>
  nameWithType.vb: IEnumerable(Of ValueTask(Of TWrite))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of TWrite))
  name.vb: IEnumerable(Of ValueTask(Of TWrite))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{TWrite}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Task<TWrite>>
  nameWithType: IEnumerable<Task<TWrite>>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TWrite>>
  nameWithType.vb: IEnumerable(Of Task(Of TWrite))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of TWrite))
  name.vb: IEnumerable(Of Task(Of TWrite))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.Source*
  commentId: Overload:Open.ChannelExtensions.Extensions.Source
  name: Source
  nameWithType: Extensions.Source
  fullName: Open.ChannelExtensions.Extensions.Source
- uid: System.Collections.Generic.IEnumerable{{TWrite}}
  commentId: T:System.Collections.Generic.IEnumerable{``0}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<TWrite>
  nameWithType: IEnumerable<TWrite>
  fullName: System.Collections.Generic.IEnumerable<TWrite>
  nameWithType.vb: IEnumerable(Of TWrite)
  fullName.vb: System.Collections.Generic.IEnumerable(Of TWrite)
  name.vb: IEnumerable(Of TWrite)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.Channel{System.String,{T}}
  commentId: T:System.Threading.Channels.Channel{System.String,``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.Channel`2
  name: Channel<String, T>
  nameWithType: Channel<String, T>
  fullName: System.Threading.Channels.Channel<System.String, T>
  nameWithType.vb: Channel(Of String, T)
  fullName.vb: System.Threading.Channels.Channel(Of System.String, T)
  name.vb: Channel(Of String, T)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.IO.TextReader
  commentId: T:System.IO.TextReader
  parent: System.IO
  isExternal: true
  name: TextReader
  nameWithType: TextReader
  fullName: System.IO.TextReader
- uid: Open.ChannelExtensions.Extensions.Transform*
  commentId: Overload:Open.ChannelExtensions.Extensions.Transform
  name: Transform
  nameWithType: Extensions.Transform
  fullName: Open.ChannelExtensions.Extensions.Transform
- uid: Open.ChannelExtensions.Extensions.OfType*
  commentId: Overload:Open.ChannelExtensions.Extensions.OfType
  name: OfType
  nameWithType: Extensions.OfType
  fullName: Open.ChannelExtensions.Extensions.OfType
- uid: System.Threading.Channels.ChannelReader{{TSource}}
  commentId: T:System.Threading.Channels.ChannelReader{``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<TSource>
  nameWithType: ChannelReader<TSource>
  fullName: System.Threading.Channels.ChannelReader<TSource>
  nameWithType.vb: ChannelReader(Of TSource)
  fullName.vb: System.Threading.Channels.ChannelReader(Of TSource)
  name.vb: ChannelReader(Of TSource)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TSource
    nameWithType: TSource
    fullName: TSource
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TSource
    nameWithType: TSource
    fullName: TSource
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.WriteAllAsync
  name: WriteAllAsync
  nameWithType: Extensions.WriteAllAsync
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync
- uid: System.Threading.Channels.ChannelWriter{{T}}
  commentId: T:System.Threading.Channels.ChannelWriter{``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelWriter`1
  name: ChannelWriter<T>
  nameWithType: ChannelWriter<T>
  fullName: System.Threading.Channels.ChannelWriter<T>
  nameWithType.vb: ChannelWriter(Of T)
  fullName.vb: System.Threading.Channels.ChannelWriter(Of T)
  name.vb: ChannelWriter(Of T)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{T}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<ValueTask<T>>
  nameWithType: IEnumerable<ValueTask<T>>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<T>>
  nameWithType.vb: IEnumerable(Of ValueTask(Of T))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of T))
  name.vb: IEnumerable(Of ValueTask(Of T))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelWriter`1
  commentId: T:System.Threading.Channels.ChannelWriter`1
  isExternal: true
  name: ChannelWriter<T>
  nameWithType: ChannelWriter<T>
  fullName: System.Threading.Channels.ChannelWriter<T>
  nameWithType.vb: ChannelWriter(Of T)
  fullName.vb: System.Threading.Channels.ChannelWriter(Of T)
  name.vb: ChannelWriter(Of T)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{T}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Task<T>>
  nameWithType: IEnumerable<Task<T>>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<T>>
  nameWithType.vb: IEnumerable(Of Task(Of T))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of T))
  name.vb: IEnumerable(Of Task(Of T))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Func{{T}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Func{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Func<T>>
  nameWithType: IEnumerable<Func<T>>
  fullName: System.Collections.Generic.IEnumerable<System.Func<T>>
  nameWithType.vb: IEnumerable(Of Func(Of T))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Func(Of T))
  name.vb: IEnumerable(Of Func(Of T))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.WriteAll*
  commentId: Overload:Open.ChannelExtensions.Extensions.WriteAll
  name: WriteAll
  nameWithType: Extensions.WriteAll
  fullName: Open.ChannelExtensions.Extensions.WriteAll
- uid: Open.ChannelExtensions.Extensions.WriteAllLines*
  commentId: Overload:Open.ChannelExtensions.Extensions.WriteAllLines
  name: WriteAllLines
  nameWithType: Extensions.WriteAllLines
  fullName: Open.ChannelExtensions.Extensions.WriteAllLines
- uid: System.Threading.Channels.ChannelWriter{System.String}
  commentId: T:System.Threading.Channels.ChannelWriter{System.String}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelWriter`1
  name: ChannelWriter<String>
  nameWithType: ChannelWriter<String>
  fullName: System.Threading.Channels.ChannelWriter<System.String>
  nameWithType.vb: ChannelWriter(Of String)
  fullName.vb: System.Threading.Channels.ChannelWriter(Of System.String)
  name.vb: ChannelWriter(Of String)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync
  name: WriteAllConcurrentlyAsync
  nameWithType: Extensions.WriteAllConcurrentlyAsync
  fullName: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync
- uid: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync
  name: WaitToWriteAndThrowIfClosedAsync
  nameWithType: Extensions.WaitToWriteAndThrowIfClosedAsync
  fullName: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync
- uid: System.String
  commentId: T:System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Tasks.ValueTask
  commentId: T:System.Threading.Tasks.ValueTask
  parent: System.Threading.Tasks
  isExternal: true
  name: ValueTask
  nameWithType: ValueTask
  fullName: System.Threading.Tasks.ValueTask
- uid: Open.ChannelExtensions.Extensions.CompleteAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.CompleteAsync
  name: CompleteAsync
  nameWithType: Extensions.CompleteAsync
  fullName: Open.ChannelExtensions.Extensions.CompleteAsync
- uid: System.Exception
  commentId: T:System.Exception
  parent: System
  isExternal: true
  name: Exception
  nameWithType: Exception
  fullName: System.Exception
- uid: System.Threading.Tasks.Task
  commentId: T:System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: Open.ChannelExtensions.Extensions.ToChannel*
  commentId: Overload:Open.ChannelExtensions.Extensions.ToChannel
  name: ToChannel
  nameWithType: Extensions.ToChannel
  fullName: Open.ChannelExtensions.Extensions.ToChannel
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ToChannelAsync
  name: ToChannelAsync
  nameWithType: Extensions.ToChannelAsync
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync
