### YamlMime:ManagedReference
items:
- uid: Open.ChannelExtensions.Extensions
  commentId: T:Open.ChannelExtensions.Extensions
  id: Extensions
  parent: Open.ChannelExtensions
  children:
  - Open.ChannelExtensions.Extensions.AsAsyncEnumerable``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.AsAsyncEnumerable``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Batch``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Boolean,System.Boolean)
  - Open.ChannelExtensions.Extensions.CompleteAsync``2(System.Threading.Channels.Channel{``0,``1},System.Exception)
  - Open.ChannelExtensions.Extensions.Filter``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Boolean})
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{``0[]},System.Boolean)
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IAsyncEnumerable{``0}},System.Boolean,System.Boolean)
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{``0}},System.Boolean)
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{``0}},System.Boolean)
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{``0}},System.Boolean)
  - Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.List{``0}},System.Boolean)
  - Open.ChannelExtensions.Extensions.OfType``2(System.Threading.Channels.ChannelReader{``0})
  - Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.PipeTo``1(System.Threading.Channels.ChannelReader{``0},System.Threading.Channels.Channel{``0},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.PipeTo``1(System.Threading.Channels.ChannelReader{``0},System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Action{``0},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken,System.Action{``0})
  - Open.ChannelExtensions.Extensions.ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Action{``1},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Threading.CancellationToken,System.Action{``1})
  - Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask})
  - Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask})
  - Open.ChannelExtensions.Extensions.ReadAvailable``1(System.Threading.Channels.ChannelReader{``0})
  - Open.ChannelExtensions.Extensions.ReadBatchAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  - Open.ChannelExtensions.Extensions.Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.Task},System.Boolean)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Boolean)
  - Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.Task},System.Boolean)
  - Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.Channels.ChannelOptions,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  - Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Channels.ChannelOptions,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.ToListAsync``1(System.Threading.Channels.ChannelReader{``0})
  - Open.ChannelExtensions.Extensions.Transform``2(System.Threading.Channels.Channel{``0},System.Func{``0,``1})
  - Open.ChannelExtensions.Extensions.Transform``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1})
  - Open.ChannelExtensions.Extensions.Transform``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2})
  - Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  - Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken)
  langs:
  - csharp
  - vb
  name: Extensions
  nameWithType: Extensions
  fullName: Open.ChannelExtensions.Extensions
  type: Class
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Extensions
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 14
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nExtensions for operating with System.Threading.Channels.\n"
  example: []
  syntax:
    content: public static class Extensions
    content.vb: Public Module Extensions
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
  modifiers.csharp:
  - public
  - static
  - class
  modifiers.vb:
  - Public
  - Module
- uid: Open.ChannelExtensions.Extensions.Batch``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Boolean,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Batch``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Boolean,System.Boolean)
  id: Batch``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Boolean,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Batch<T>(ChannelReader<T>, Int32, Boolean, Boolean)
  nameWithType: Extensions.Batch<T>(ChannelReader<T>, Int32, Boolean, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Batch<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Boolean, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Batch.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Batch
    path: ../Open.ChannelExtensions/Extensions.Batch.cs
    startLine: 73
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nBatches results into the batch size provided with a max capacity of batches.\n"
  example: []
  syntax:
    content: public static ChannelReader<List<T>> Batch<T>(this ChannelReader<T> source, int batchSize, bool singleReader = false, bool allowSynchronousContinuations = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel to read from.
    - id: batchSize
      type: System.Int32
      description: The maximum size of each batch.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: allowSynchronousContinuations
      type: System.Boolean
      description: True can reduce the amount of scheduling and markedly improve performance, but may produce unexpected or even undesirable behavior.
    typeParameters:
    - id: T
      description: The output type of the source channel.
    return:
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.List{{T}}}
      description: A channel reader containing the batches.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Batch(Of T)(source As ChannelReader(Of T), batchSize As Integer, singleReader As Boolean = False, allowSynchronousContinuations As Boolean = False) As ChannelReader(Of List(Of T))
  overload: Open.ChannelExtensions.Extensions.Batch*
  nameWithType.vb: Extensions.Batch(Of T)(ChannelReader(Of T), Int32, Boolean, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Batch(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Boolean, System.Boolean)
  name.vb: Batch(Of T)(ChannelReader(Of T), Int32, Boolean, Boolean)
- uid: Open.ChannelExtensions.Extensions.Filter``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Boolean})
  commentId: M:Open.ChannelExtensions.Extensions.Filter``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Boolean})
  id: Filter``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Boolean})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Filter<T>(ChannelReader<T>, Func<T, Boolean>)
  nameWithType: Extensions.Filter<T>(ChannelReader<T>, Func<T, Boolean>)
  fullName: Open.ChannelExtensions.Extensions.Filter<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Boolean>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Filter.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Filter
    path: ../Open.ChannelExtensions/Extensions.Filter.cs
    startLine: 46
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nProduces a reader that only contains results that pass the predicate condition.  Ones that fail the predicate are discarded.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Filter<T>(this ChannelReader<T> source, Func<T, bool> predicate)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The source channel reader.
    - id: predicate
      type: System.Func{{T},System.Boolean}
      description: The predicate function.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader representing the filtered results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Filter(Of T)(source As ChannelReader(Of T), predicate As Func(Of T, Boolean)) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Filter*
  nameWithType.vb: Extensions.Filter(Of T)(ChannelReader(Of T), Func(Of T, Boolean))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Filter(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Boolean))
  name.vb: Filter(Of T)(ChannelReader(Of T), Func(Of T, Boolean))
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{``0}},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{``0}},System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{``0}},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<IEnumerable<T>>, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<IEnumerable<T>>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<System.Collections.Generic.IEnumerable<T>>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: ../Open.ChannelExtensions/Extensions.Join.cs
    startLine: 45
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<IEnumerable<T>> source, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{{T}}}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of IEnumerable(Of T)), singleReader As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of IEnumerable(Of T)), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of System.Collections.Generic.IEnumerable(Of T)), System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of IEnumerable(Of T)), Boolean)
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{``0}},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{``0}},System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{``0}},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<ICollection<T>>, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<ICollection<T>>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<System.Collections.Generic.ICollection<T>>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: ../Open.ChannelExtensions/Extensions.Join.cs
    startLine: 55
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<ICollection<T>> source, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{{T}}}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of ICollection(Of T)), singleReader As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of ICollection(Of T)), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of System.Collections.Generic.ICollection(Of T)), System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of ICollection(Of T)), Boolean)
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{``0}},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{``0}},System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{``0}},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<IList<T>>, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<IList<T>>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<System.Collections.Generic.IList<T>>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: ../Open.ChannelExtensions/Extensions.Join.cs
    startLine: 65
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<IList<T>> source, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{{T}}}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of IList(Of T)), singleReader As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of IList(Of T)), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of System.Collections.Generic.IList(Of T)), System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of IList(Of T)), Boolean)
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.List{``0}},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.List{``0}},System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.List{``0}},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<List<T>>, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<List<T>>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<System.Collections.Generic.List<T>>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: ../Open.ChannelExtensions/Extensions.Join.cs
    startLine: 75
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<List<T>> source, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.List{{T}}}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of List(Of T)), singleReader As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of List(Of T)), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of System.Collections.Generic.List(Of T)), System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of List(Of T)), Boolean)
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{``0[]},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{``0[]},System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{``0[]},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<T[]>, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<T[]>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<T[]>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: ../Open.ChannelExtensions/Extensions.Join.cs
    startLine: 85
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<T[]> source, bool singleReader = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{T}[]}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of T()), singleReader As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of T()), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of T()), System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of T()), Boolean)
- uid: Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IAsyncEnumerable{``0}},System.Boolean,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IAsyncEnumerable{``0}},System.Boolean,System.Boolean)
  id: Join``1(System.Threading.Channels.ChannelReader{System.Collections.Generic.IAsyncEnumerable{``0}},System.Boolean,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Join<T>(ChannelReader<IAsyncEnumerable<T>>, Boolean, Boolean)
  nameWithType: Extensions.Join<T>(ChannelReader<IAsyncEnumerable<T>>, Boolean, Boolean)
  fullName: Open.ChannelExtensions.Extensions.Join<T>(System.Threading.Channels.ChannelReader<System.Collections.Generic.IAsyncEnumerable<T>>, System.Boolean, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Join.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Join
    path: ../Open.ChannelExtensions/Extensions.Join.cs
    startLine: 97
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nJoins collections of the same type into a single channel reader in the order provided.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Join<T>(this ChannelReader<IAsyncEnumerable<T>> source, bool singleReader = false, bool allowSynchronousContinuations = false)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{System.Collections.Generic.IAsyncEnumerable{{T}}}
      description: The source reader.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: allowSynchronousContinuations
      type: System.Boolean
      description: True can reduce the amount of scheduling and markedly improve performance, but may produce unexpected or even undesirable behavior.
    typeParameters:
    - id: T
      description: The result type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader containing the joined results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Join(Of T)(source As ChannelReader(Of IAsyncEnumerable(Of T)), singleReader As Boolean = False, allowSynchronousContinuations As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Join*
  nameWithType.vb: Extensions.Join(Of T)(ChannelReader(Of IAsyncEnumerable(Of T)), Boolean, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Join(Of T)(System.Threading.Channels.ChannelReader(Of System.Collections.Generic.IAsyncEnumerable(Of T)), System.Boolean, System.Boolean)
  name.vb: Join(Of T)(ChannelReader(Of IAsyncEnumerable(Of T)), Boolean, Boolean)
- uid: Open.ChannelExtensions.Extensions.PipeTo``1(System.Threading.Channels.ChannelReader{``0},System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.PipeTo``1(System.Threading.Channels.ChannelReader{``0},System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  id: PipeTo``1(System.Threading.Channels.ChannelReader{``0},System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: PipeTo<T>(ChannelReader<T>, ChannelWriter<T>, Boolean, CancellationToken)
  nameWithType: Extensions.PipeTo<T>(ChannelReader<T>, ChannelWriter<T>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.PipeTo<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.Channels.ChannelWriter<T>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: PipeTo
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 21
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries from the source channel and writes them to the target.\nThis is useful for managing different buffers sizes, especially if the source reader comes from a .Transform function.\n"
  example: []
  syntax:
    content: public static ValueTask<long> PipeTo<T>(this ChannelReader<T> source, ChannelWriter<T> target, bool complete, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The source channel.
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The target channel.
    - id: complete
      type: System.Boolean
      description: Indicates to call complete on the target when the source is complete.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The type contained by the source channel and written to the target..
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function PipeTo(Of T)(source As ChannelReader(Of T), target As ChannelWriter(Of T), complete As Boolean, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.PipeTo*
  nameWithType.vb: Extensions.PipeTo(Of T)(ChannelReader(Of T), ChannelWriter(Of T), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.PipeTo(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.Channels.ChannelWriter(Of T), System.Boolean, System.Threading.CancellationToken)
  name.vb: PipeTo(Of T)(ChannelReader(Of T), ChannelWriter(Of T), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.PipeTo``1(System.Threading.Channels.ChannelReader{``0},System.Threading.Channels.Channel{``0},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.PipeTo``1(System.Threading.Channels.ChannelReader{``0},System.Threading.Channels.Channel{``0},System.Threading.CancellationToken)
  id: PipeTo``1(System.Threading.Channels.ChannelReader{``0},System.Threading.Channels.Channel{``0},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: PipeTo<T>(ChannelReader<T>, Channel<T>, CancellationToken)
  nameWithType: Extensions.PipeTo<T>(ChannelReader<T>, Channel<T>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.PipeTo<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.Channels.Channel<T>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: PipeTo
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 59
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries from the source channel and writes them to the target.  Will call complete when finished and propagates any errors to the channel.\nThis is useful for managing different buffers sizes, especially if the source reader comes from a .Transform function.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> PipeTo<T>(this ChannelReader<T> source, Channel<T> target, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The source channel.
    - id: target
      type: System.Threading.Channels.Channel{{T}}
      description: The target channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The type contained by the source channel and written to the target..
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader of the target.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function PipeTo(Of T)(source As ChannelReader(Of T), target As Channel(Of T), cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.PipeTo*
  nameWithType.vb: Extensions.PipeTo(Of T)(ChannelReader(Of T), Channel(Of T), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.PipeTo(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.Channels.Channel(Of T), System.Threading.CancellationToken)
  name.vb: PipeTo(Of T)(ChannelReader(Of T), Channel(Of T), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: PipeAsync<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.PipeAsync<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.PipeAsync<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Int32, System.Func<TIn, System.Threading.Tasks.ValueTask<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: PipeAsync
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 84
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries concurrently and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> PipeAsync<TIn, TOut>(this ChannelReader<TIn> source, int maxConcurrency, Func<TIn, ValueTask<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: transform
      type: System.Func{{TIn},System.Threading.Tasks.ValueTask{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function PipeAsync(Of TIn, TOut)(source As ChannelReader(Of TIn), maxConcurrency As Integer, transform As Func(Of TIn, ValueTask(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.PipeAsync*
  nameWithType.vb: Extensions.PipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.PipeAsync(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Int32, System.Func(Of TIn, System.Threading.Tasks.ValueTask(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: PipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: PipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.PipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.PipeAsync<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Func<TRead, System.Threading.Tasks.ValueTask<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: PipeAsync
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 126
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> PipeAsync<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, int maxConcurrency, Func<TRead, ValueTask<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: transform
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function PipeAsync(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), maxConcurrency As Integer, transform As Func(Of TRead, ValueTask(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.PipeAsync*
  nameWithType.vb: Extensions.PipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.PipeAsync(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Func(Of TRead, System.Threading.Tasks.ValueTask(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: PipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskPipeAsync<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, Task<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.TaskPipeAsync<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, Task<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskPipeAsync<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Int32, System.Func<TIn, System.Threading.Tasks.Task<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskPipeAsync
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 148
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> TaskPipeAsync<TIn, TOut>(this ChannelReader<TIn> source, int maxConcurrency, Func<TIn, Task<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: transform
      type: System.Func{{TIn},System.Threading.Tasks.Task{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskPipeAsync(Of TIn, TOut)(source As ChannelReader(Of TIn), maxConcurrency As Integer, transform As Func(Of TIn, Task(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.TaskPipeAsync*
  nameWithType.vb: Extensions.TaskPipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, Task(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskPipeAsync(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Int32, System.Func(Of TIn, System.Threading.Tasks.Task(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskPipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, Task(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskPipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, Task<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.TaskPipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, Task<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskPipeAsync<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Func<TRead, System.Threading.Tasks.Task<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskPipeAsync
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 166
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> TaskPipeAsync<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, int maxConcurrency, Func<TRead, Task<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: transform
      type: System.Func{{TRead},System.Threading.Tasks.Task{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskPipeAsync(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), maxConcurrency As Integer, transform As Func(Of TRead, Task(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.TaskPipeAsync*
  nameWithType.vb: Extensions.TaskPipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, Task(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskPipeAsync(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Func(Of TRead, System.Threading.Tasks.Task(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskPipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, Task(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Pipe<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, TOut>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.Pipe<TIn, TOut>(ChannelReader<TIn>, Int32, Func<TIn, TOut>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Pipe<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Int32, System.Func<TIn, TOut>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Pipe
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 188
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> Pipe<TIn, TOut>(this ChannelReader<TIn> source, int maxConcurrency, Func<TIn, TOut> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: transform
      type: System.Func{{TIn},{TOut}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Pipe(Of TIn, TOut)(source As ChannelReader(Of TIn), maxConcurrency As Integer, transform As Func(Of TIn, TOut), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.Pipe*
  nameWithType.vb: Extensions.Pipe(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, TOut), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Pipe(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Int32, System.Func(Of TIn, TOut), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: Pipe(Of TIn, TOut)(ChannelReader(Of TIn), Int32, Func(Of TIn, TOut), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Pipe<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, TOut>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.Pipe<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Int32, Func<TRead, TOut>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Pipe<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Func<TRead, TOut>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Pipe
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 206
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> Pipe<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, int maxConcurrency, Func<TRead, TOut> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: transform
      type: System.Func{{TRead},{TOut}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Pipe(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), maxConcurrency As Integer, transform As Func(Of TRead, TOut), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.Pipe*
  nameWithType.vb: Extensions.Pipe(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, TOut), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Pipe(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Func(Of TRead, TOut), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: Pipe(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, TOut), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: PipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: PipeAsync<TIn, TOut>(ChannelReader<TIn>, Func<TIn, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.PipeAsync<TIn, TOut>(ChannelReader<TIn>, Func<TIn, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.PipeAsync<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Func<TIn, System.Threading.Tasks.ValueTask<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: PipeAsync
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 227
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> PipeAsync<TIn, TOut>(this ChannelReader<TIn> source, Func<TIn, ValueTask<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: transform
      type: System.Func{{TIn},System.Threading.Tasks.ValueTask{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function PipeAsync(Of TIn, TOut)(source As ChannelReader(Of TIn), transform As Func(Of TIn, ValueTask(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.PipeAsync*
  nameWithType.vb: Extensions.PipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.PipeAsync(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Func(Of TIn, System.Threading.Tasks.ValueTask(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: PipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: PipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: PipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.PipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, ValueTask<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.PipeAsync<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Threading.Tasks.ValueTask<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: PipeAsync
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 244
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> PipeAsync<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, Func<TRead, ValueTask<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: transform
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function PipeAsync(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), transform As Func(Of TRead, ValueTask(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.PipeAsync*
  nameWithType.vb: Extensions.PipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.PipeAsync(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Threading.Tasks.ValueTask(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: PipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, ValueTask(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: TaskPipeAsync``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskPipeAsync<TIn, TOut>(ChannelReader<TIn>, Func<TIn, Task<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.TaskPipeAsync<TIn, TOut>(ChannelReader<TIn>, Func<TIn, Task<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskPipeAsync<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Func<TIn, System.Threading.Tasks.Task<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskPipeAsync
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 265
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> TaskPipeAsync<TIn, TOut>(this ChannelReader<TIn> source, Func<TIn, Task<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: transform
      type: System.Func{{TIn},System.Threading.Tasks.Task{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskPipeAsync(Of TIn, TOut)(source As ChannelReader(Of TIn), transform As Func(Of TIn, Task(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.TaskPipeAsync*
  nameWithType.vb: Extensions.TaskPipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, Task(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskPipeAsync(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Func(Of TIn, System.Threading.Tasks.Task(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskPipeAsync(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, Task(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: TaskPipeAsync``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task{``2}},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskPipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, Task<TOut>>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.TaskPipeAsync<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, Task<TOut>>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskPipeAsync<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Threading.Tasks.Task<TOut>>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskPipeAsync
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 282
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> TaskPipeAsync<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, Func<TRead, Task<TOut>> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: transform
      type: System.Func{{TRead},System.Threading.Tasks.Task{{TOut}}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskPipeAsync(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), transform As Func(Of TRead, Task(Of TOut)), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.TaskPipeAsync*
  nameWithType.vb: Extensions.TaskPipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, Task(Of TOut)), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskPipeAsync(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Threading.Tasks.Task(Of TOut)), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskPipeAsync(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, Task(Of TOut)), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: Pipe``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Pipe<TIn, TOut>(ChannelReader<TIn>, Func<TIn, TOut>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.Pipe<TIn, TOut>(ChannelReader<TIn>, Func<TIn, TOut>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Pipe<TIn, TOut>(System.Threading.Channels.ChannelReader<TIn>, System.Func<TIn, TOut>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Pipe
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 303
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> Pipe<TIn, TOut>(this ChannelReader<TIn> source, Func<TIn, TOut> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TIn}}
      description: The source channel.
    - id: transform
      type: System.Func{{TIn},{TOut}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TIn
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Pipe(Of TIn, TOut)(source As ChannelReader(Of TIn), transform As Func(Of TIn, TOut), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.Pipe*
  nameWithType.vb: Extensions.Pipe(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, TOut), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Pipe(Of TIn, TOut)(System.Threading.Channels.ChannelReader(Of TIn), System.Func(Of TIn, TOut), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: Pipe(Of TIn, TOut)(ChannelReader(Of TIn), Func(Of TIn, TOut), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  id: Pipe``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2},System.Int32,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Pipe<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, TOut>, Int32, Boolean, CancellationToken)
  nameWithType: Extensions.Pipe<TWrite, TRead, TOut>(Channel<TWrite, TRead>, Func<TRead, TOut>, Int32, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Pipe<TWrite, TRead, TOut>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, TOut>, System.Int32, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Pipe.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Pipe
    path: ../Open.ChannelExtensions/Extensions.Pipe.cs
    startLine: 320
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads all entries and applies the values to the provided transform function before buffering the results into another channel for consumption.\n"
  example: []
  syntax:
    content: public static ChannelReader<TOut> Pipe<TWrite, TRead, TOut>(this Channel<TWrite, TRead> source, Func<TRead, TOut> transform, int capacity = -1, bool singleReader = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel.
    - id: transform
      type: System.Func{{TRead},{TOut}}
      description: The transform function to apply the source entries before passing on to the output.
    - id: capacity
      type: System.Int32
      description: 'The width of the pipe: how many entries to buffer while waiting to be read from.'
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The type being accepted by the channel.
    - id: TRead
      description: The type contained by the source channel.
    - id: TOut
      description: The outgoing type from the resultant channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TOut}}
      description: The channel reader containing the output.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Pipe(Of TWrite, TRead, TOut)(source As Channel(Of TWrite, TRead), transform As Func(Of TRead, TOut), capacity As Integer = -1, singleReader As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TOut)
  overload: Open.ChannelExtensions.Extensions.Pipe*
  nameWithType.vb: Extensions.Pipe(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, TOut), Int32, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Pipe(Of TWrite, TRead, TOut)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, TOut), System.Int32, System.Boolean, System.Threading.CancellationToken)
  name.vb: Pipe(Of TWrite, TRead, TOut)(Channel(Of TWrite, TRead), Func(Of TRead, TOut), Int32, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAvailable``1(System.Threading.Channels.ChannelReader{``0})
  commentId: M:Open.ChannelExtensions.Extensions.ReadAvailable``1(System.Threading.Channels.ChannelReader{``0})
  id: ReadAvailable``1(System.Threading.Channels.ChannelReader{``0})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAvailable<T>(ChannelReader<T>)
  nameWithType: Extensions.ReadAvailable<T>(ChannelReader<T>)
  fullName: Open.ChannelExtensions.Extensions.ReadAvailable<T>(System.Threading.Channels.ChannelReader<T>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAvailable
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 20
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nCreates an enumerable that will read from the channel until no more are available for read.\n"
  example: []
  syntax:
    content: public static IEnumerable<T> ReadAvailable<T>(this ChannelReader<T> reader)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Collections.Generic.IEnumerable{{T}}
      description: An enumerable that will read from the channel until no more are available for read
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAvailable(Of T)(reader As ChannelReader(Of T)) As IEnumerable(Of T)
  overload: Open.ChannelExtensions.Extensions.ReadAvailable*
  nameWithType.vb: Extensions.ReadAvailable(Of T)(ChannelReader(Of T))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAvailable(Of T)(System.Threading.Channels.ChannelReader(Of T))
  name.vb: ReadAvailable(Of T)(ChannelReader(Of T))
- uid: Open.ChannelExtensions.Extensions.ReadBatchAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadBatchAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken)
  id: ReadBatchAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadBatchAsync<T>(ChannelReader<T>, Int32, CancellationToken)
  nameWithType: Extensions.ReadBatchAsync<T>(ChannelReader<T>, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadBatchAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadBatchAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 37
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads from the channel up to the max count.\n"
  example: []
  syntax:
    content: public static ValueTask<List<T>> ReadBatchAsync<T>(this ChannelReader<T> reader, int max, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: max
      type: System.Int32
      description: The max size of the batch.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Collections.Generic.List{{T}}}
      description: The batch requested.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadBatchAsync(Of T)(reader As ChannelReader(Of T), max As Integer, cancellationToken As CancellationToken = Nothing) As ValueTask(Of List(Of T))
  overload: Open.ChannelExtensions.Extensions.ReadBatchAsync*
  nameWithType.vb: Extensions.ReadBatchAsync(Of T)(ChannelReader(Of T), Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadBatchAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Threading.CancellationToken)
  name.vb: ReadBatchAsync(Of T)(ChannelReader(Of T), Int32, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelledAsync<T>(ChannelReader<T>, CancellationToken, Func<T, Int64, ValueTask>, Boolean)
  nameWithType: Extensions.ReadUntilCancelledAsync<T>(ChannelReader<T>, CancellationToken, Func<T, Int64, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Func<T, System.Int64, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelledAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 76
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelledAsync<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Func<T, long, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{T},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelledAsync(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Func(Of T, Long, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync*
  nameWithType.vb: Extensions.ReadUntilCancelledAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, Int64, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Func(Of T, System.Int64, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadUntilCancelledAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, Int64, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelledAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, Int64, ValueTask>, Boolean)
  nameWithType: Extensions.ReadUntilCancelledAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, Int64, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Func<TRead, System.Int64, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelledAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 120
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelledAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Func<TRead, long, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{TRead},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelledAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Func(Of TRead, Long, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync*
  nameWithType.vb: Extensions.ReadUntilCancelledAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, Int64, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Func(Of TRead, System.Int64, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadUntilCancelledAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, Int64, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadUntilCancelledAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelledAsync<T>(ChannelReader<T>, CancellationToken, Func<T, ValueTask>, Boolean)
  nameWithType: Extensions.ReadUntilCancelledAsync<T>(ChannelReader<T>, CancellationToken, Func<T, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Func<T, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelledAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 142
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelledAsync<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Func<T, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelledAsync(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Func(Of T, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync*
  nameWithType.vb: Extensions.ReadUntilCancelledAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Func(Of T, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadUntilCancelledAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadUntilCancelledAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelledAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, ValueTask>, Boolean)
  nameWithType: Extensions.ReadUntilCancelledAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Func<TRead, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelledAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 160
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelledAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Func<TRead, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelledAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Func(Of TRead, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync*
  nameWithType.vb: Extensions.ReadUntilCancelledAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Func(Of TRead, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadUntilCancelledAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  id: ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelled<T>(ChannelReader<T>, CancellationToken, Action<T, Int64>, Boolean)
  nameWithType: Extensions.ReadUntilCancelled<T>(ChannelReader<T>, CancellationToken, Action<T, Int64>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelled<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Action<T, System.Int64>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelled
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 182
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelled<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Action<T, long> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Action{{T},System.Int64}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelled(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Action(Of T, Long), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelled*
  nameWithType.vb: Extensions.ReadUntilCancelled(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T, Int64), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelled(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Action(Of T, System.Int64), System.Boolean)
  name.vb: ReadUntilCancelled(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T, Int64), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  id: ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelled<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Action<TRead, Int64>, Boolean)
  nameWithType: Extensions.ReadUntilCancelled<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Action<TRead, Int64>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelled<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Action<TRead, System.Int64>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelled
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 208
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelled<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Action<TRead, long> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Action{{TRead},System.Int64}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelled(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Action(Of TRead, Long), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelled*
  nameWithType.vb: Extensions.ReadUntilCancelled(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Action(Of TRead, Int64), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelled(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Action(Of TRead, System.Int64), System.Boolean)
  name.vb: ReadUntilCancelled(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Action(Of TRead, Int64), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  id: ReadUntilCancelled``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelled<T>(ChannelReader<T>, CancellationToken, Action<T>, Boolean)
  nameWithType: Extensions.ReadUntilCancelled<T>(ChannelReader<T>, CancellationToken, Action<T>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelled<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Action<T>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelled
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 230
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelled<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Action<T> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Action{{T}}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelled(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Action(Of T), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelled*
  nameWithType.vb: Extensions.ReadUntilCancelled(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelled(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Action(Of T), System.Boolean)
  name.vb: ReadUntilCancelled(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  id: ReadUntilCancelled``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadUntilCancelled<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadUntilCancelled<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelled<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Action<TRead>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadUntilCancelled
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 255
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadUntilCancelled<TWrite, TRead>(this Channel<TWrite, TRead> channel, Action<TRead> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Action{{TRead}}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadUntilCancelled(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Action(Of TRead), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadUntilCancelled*
  nameWithType.vb: Extensions.ReadUntilCancelled(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadUntilCancelled(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Action(Of TRead), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadUntilCancelled(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  id: ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<T>(ChannelReader<T>, Func<T, Int64, ValueTask>, Boolean, CancellationToken)
  nameWithType: Extensions.ReadAllAsync<T>(ChannelReader<T>, Func<T, Int64, ValueTask>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Int64, System.Threading.Tasks.ValueTask>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 276
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<T>(this ChannelReader<T> reader, Func<T, long, ValueTask> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Func{{T},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of T)(reader As ChannelReader(Of T), receiver As Func(Of T, Long, ValueTask), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Int64, ValueTask), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Int64, System.Threading.Tasks.ValueTask), System.Boolean, System.Threading.CancellationToken)
  name.vb: ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Int64, ValueTask), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<T>(ChannelReader<T>, Func<T, Int64, ValueTask>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsync<T>(ChannelReader<T>, Func<T, Int64, ValueTask>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Int64, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 296
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<T>(this ChannelReader<T> reader, Func<T, long, ValueTask> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Func{{T},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of T)(reader As ChannelReader(Of T), receiver As Func(Of T, Long, ValueTask), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Int64, ValueTask), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Int64, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Int64, ValueTask), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<T>(ChannelReader<T>, CancellationToken, Func<T, Int64, ValueTask>, Boolean)
  nameWithType: Extensions.ReadAllAsync<T>(ChannelReader<T>, CancellationToken, Func<T, Int64, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Func<T, System.Int64, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 312
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Func<T, long, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{T},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Func(Of T, Long, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, Int64, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Func(Of T, System.Int64, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadAllAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, Int64, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  id: ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, ValueTask>, Boolean, CancellationToken)
  nameWithType: Extensions.ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, ValueTask>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Int64, System.Threading.Tasks.ValueTask>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 330
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, long, ValueTask> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, Long, ValueTask), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, ValueTask), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Int64, System.Threading.Tasks.ValueTask), System.Boolean, System.Threading.CancellationToken)
  name.vb: ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, ValueTask), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, ValueTask>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, ValueTask>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Int64, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 352
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, long, ValueTask> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, Long, ValueTask), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, ValueTask), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Int64, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, ValueTask), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, Int64, ValueTask>, Boolean)
  nameWithType: Extensions.ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, Int64, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Func<TRead, System.Int64, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 369
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Func<TRead, long, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{TRead},System.Int64,System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Func(Of TRead, Long, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, Int64, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Func(Of TRead, System.Int64, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, Int64, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  id: TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, Task>, Boolean, CancellationToken)
  nameWithType: Extensions.TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, Task>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Int64, System.Threading.Tasks.Task>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 387
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, long, Task> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Int64,System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, Long, Task), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, Task), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Int64, System.Threading.Tasks.Task), System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, Task), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  id: TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, Task>, CancellationToken, Boolean)
  nameWithType: Extensions.TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Int64, Task>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Int64, System.Threading.Tasks.Task>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 404
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, long, Task> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Int64,System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, Long, Task), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, Task), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Int64, System.Threading.Tasks.Task), System.Threading.CancellationToken, System.Boolean)
  name.vb: TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Int64, Task), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Boolean)
  id: TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Int64,System.Threading.Tasks.Task},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, Int64, Task>, Boolean)
  nameWithType: Extensions.TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, Int64, Task>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Func<TRead, System.Int64, System.Threading.Tasks.Task>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 421
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Func<TRead, long, Task> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: receiver
      type: System.Func{{TRead},System.Int64,System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Func(Of TRead, Long, Task), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, Int64, Task), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Func(Of TRead, System.Int64, System.Threading.Tasks.Task), System.Boolean)
  name.vb: TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, Int64, Task), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  id: ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<T>(ChannelReader<T>, Func<T, ValueTask>, Boolean, CancellationToken)
  nameWithType: Extensions.ReadAllAsync<T>(ChannelReader<T>, Func<T, ValueTask>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Threading.Tasks.ValueTask>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 438
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<T>(this ChannelReader<T> reader, Func<T, ValueTask> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of T)(reader As ChannelReader(Of T), receiver As Func(Of T, ValueTask), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, ValueTask), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Threading.Tasks.ValueTask), System.Boolean, System.Threading.CancellationToken)
  name.vb: ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, ValueTask), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<T>(ChannelReader<T>, Func<T, ValueTask>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsync<T>(ChannelReader<T>, Func<T, ValueTask>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 454
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<T>(this ChannelReader<T> reader, Func<T, ValueTask> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of T)(reader As ChannelReader(Of T), receiver As Func(Of T, ValueTask), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, ValueTask), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, ValueTask), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<T>(ChannelReader<T>, CancellationToken, Func<T, ValueTask>, Boolean)
  nameWithType: Extensions.ReadAllAsync<T>(ChannelReader<T>, CancellationToken, Func<T, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Func<T, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 470
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Func<T, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Func(Of T, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Func(Of T, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadAllAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  id: TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<T>(ChannelReader<T>, Func<T, Task>, Boolean, CancellationToken)
  nameWithType: Extensions.TaskReadAllAsync<T>(ChannelReader<T>, Func<T, Task>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Threading.Tasks.Task>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 487
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<T>(this ChannelReader<T> reader, Func<T, Task> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of T)(reader As ChannelReader(Of T), receiver As Func(Of T, Task), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Task), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Threading.Tasks.Task), System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Task), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  id: TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<T>(ChannelReader<T>, Func<T, Task>, CancellationToken, Boolean)
  nameWithType: Extensions.TaskReadAllAsync<T>(ChannelReader<T>, Func<T, Task>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Func<T, System.Threading.Tasks.Task>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 503
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<T>(this ChannelReader<T> reader, Func<T, Task> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of T)(reader As ChannelReader(Of T), receiver As Func(Of T, Task), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Task), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, System.Threading.Tasks.Task), System.Threading.CancellationToken, System.Boolean)
  name.vb: TaskReadAllAsync(Of T)(ChannelReader(Of T), Func(Of T, Task), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.Task},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.Task},System.Boolean)
  id: TaskReadAllAsync``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.Task},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<T>(ChannelReader<T>, CancellationToken, Func<T, Task>, Boolean)
  nameWithType: Extensions.TaskReadAllAsync<T>(ChannelReader<T>, CancellationToken, Func<T, Task>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Func<T, System.Threading.Tasks.Task>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 519
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Func<T, Task> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Func(Of T, Task), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, Task), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Func(Of T, System.Threading.Tasks.Task), System.Boolean)
  name.vb: TaskReadAllAsync(Of T)(ChannelReader(Of T), CancellationToken, Func(Of T, Task), Boolean)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  id: TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Task>, Boolean, CancellationToken)
  nameWithType: Extensions.TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Task>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Threading.Tasks.Task>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 537
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, Task> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, Task), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Task), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Threading.Tasks.Task), System.Boolean, System.Threading.CancellationToken)
  name.vb: TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Task), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  id: TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Task>, CancellationToken, Boolean)
  nameWithType: Extensions.TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, Task>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Threading.Tasks.Task>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 554
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, Task> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, Task), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Task), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Threading.Tasks.Task), System.Threading.CancellationToken, System.Boolean)
  name.vb: TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, Task), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.Task},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.Task},System.Boolean)
  id: TaskReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.Task},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, Task>, Boolean)
  nameWithType: Extensions.TaskReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, Task>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Func<TRead, System.Threading.Tasks.Task>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 571
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> TaskReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Func<TRead, Task> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Func(Of TRead, Task), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  nameWithType.vb: Extensions.TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, Task), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Func(Of TRead, System.Threading.Tasks.Task), System.Boolean)
  name.vb: TaskReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, Task), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  id: ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, ValueTask>, Boolean, CancellationToken)
  nameWithType: Extensions.ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, ValueTask>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Threading.Tasks.ValueTask>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 589
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, ValueTask> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, ValueTask), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, ValueTask), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Threading.Tasks.ValueTask), System.Boolean, System.Threading.CancellationToken)
  name.vb: ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, ValueTask), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, ValueTask>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, Func<TRead, ValueTask>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 612
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Func<TRead, ValueTask> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Func(Of TRead, ValueTask), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, ValueTask), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Func(Of TRead, ValueTask), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  id: ReadAllAsync``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, ValueTask>, Boolean)
  nameWithType: Extensions.ReadAllAsync<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Func<TRead, ValueTask>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Func<TRead, System.Threading.Tasks.ValueTask>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 629
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Func<TRead, ValueTask> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Func(Of TRead, ValueTask), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsync*
  nameWithType.vb: Extensions.ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, ValueTask), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Func(Of TRead, System.Threading.Tasks.ValueTask), System.Boolean)
  name.vb: ReadAllAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Func(Of TRead, ValueTask), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Boolean,System.Threading.CancellationToken)
  id: ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<T>(ChannelReader<T>, Action<T, Int64>, Boolean, CancellationToken)
  nameWithType: Extensions.ReadAll<T>(ChannelReader<T>, Action<T, Int64>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<T>(System.Threading.Channels.ChannelReader<T>, System.Action<T, System.Int64>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 646
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<T>(this ChannelReader<T> reader, Action<T, long> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Action{{T},System.Int64}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writreadinging.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of T)(reader As ChannelReader(Of T), receiver As Action(Of T, Long), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of T)(ChannelReader(Of T), Action(Of T, Int64), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Action(Of T, System.Int64), System.Boolean, System.Threading.CancellationToken)
  name.vb: ReadAll(Of T)(ChannelReader(Of T), Action(Of T, Int64), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Threading.CancellationToken,System.Boolean)
  id: ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0,System.Int64},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<T>(ChannelReader<T>, Action<T, Int64>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAll<T>(ChannelReader<T>, Action<T, Int64>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<T>(System.Threading.Channels.ChannelReader<T>, System.Action<T, System.Int64>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 675
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<T>(this ChannelReader<T> reader, Action<T, long> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Action{{T},System.Int64}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writreadinging.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of T)(reader As ChannelReader(Of T), receiver As Action(Of T, Long), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of T)(ChannelReader(Of T), Action(Of T, Int64), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Action(Of T, System.Int64), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAll(Of T)(ChannelReader(Of T), Action(Of T, Int64), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  id: ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0,System.Int64},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<T>(ChannelReader<T>, CancellationToken, Action<T, Int64>, Boolean)
  nameWithType: Extensions.ReadAll<T>(ChannelReader<T>, CancellationToken, Action<T, Int64>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Action<T, System.Int64>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 691
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Action<T, long> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Action{{T},System.Int64}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writreadinging.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Action(Of T, Long), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T, Int64), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Action(Of T, System.Int64), System.Boolean)
  name.vb: ReadAll(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T, Int64), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Boolean,System.Threading.CancellationToken)
  id: ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead, Int64>, Boolean, CancellationToken)
  nameWithType: Extensions.ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead, Int64>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Action<TRead, System.Int64>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 709
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<TWrite, TRead>(this Channel<TWrite, TRead> channel, Action<TRead, long> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Action{{TRead},System.Int64}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Action(Of TRead, Long), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead, Int64), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Action(Of TRead, System.Int64), System.Boolean, System.Threading.CancellationToken)
  name.vb: ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead, Int64), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Threading.CancellationToken,System.Boolean)
  id: ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1,System.Int64},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead, Int64>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead, Int64>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Action<TRead, System.Int64>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 732
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<TWrite, TRead>(this Channel<TWrite, TRead> channel, Action<TRead, long> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Action{{TRead},System.Int64}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Action(Of TRead, Long), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead, Int64), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Action(Of TRead, System.Int64), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead, Int64), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  id: ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1,System.Int64},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Action<TRead, Int64>, Boolean)
  nameWithType: Extensions.ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Action<TRead, Int64>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Action<TRead, System.Int64>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 749
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Action<TRead, long> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The optional cancellation token.
    - id: receiver
      type: System.Action{{TRead},System.Int64}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Action(Of TRead, Long), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Action(Of TRead, Int64), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Action(Of TRead, System.Int64), System.Boolean)
  name.vb: ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Action(Of TRead, Int64), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Boolean,System.Threading.CancellationToken)
  id: ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<T>(ChannelReader<T>, Action<T>, Boolean, CancellationToken)
  nameWithType: Extensions.ReadAll<T>(ChannelReader<T>, Action<T>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<T>(System.Threading.Channels.ChannelReader<T>, System.Action<T>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 766
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<T>(this ChannelReader<T> reader, Action<T> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Action{{T}}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of T)(reader As ChannelReader(Of T), receiver As Action(Of T), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of T)(ChannelReader(Of T), Action(Of T), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Action(Of T), System.Boolean, System.Threading.CancellationToken)
  name.vb: ReadAll(Of T)(ChannelReader(Of T), Action(Of T), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Threading.CancellationToken,System.Boolean)
  id: ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Action{``0},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<T>(ChannelReader<T>, Action<T>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAll<T>(ChannelReader<T>, Action<T>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<T>(System.Threading.Channels.ChannelReader<T>, System.Action<T>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 794
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<T>(this ChannelReader<T> reader, Action<T> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: receiver
      type: System.Action{{T}}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of T)(reader As ChannelReader(Of T), receiver As Action(Of T), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of T)(ChannelReader(Of T), Action(Of T), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Action(Of T), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAll(Of T)(ChannelReader(Of T), Action(Of T), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  id: ReadAll``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken,System.Action{``0},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<T>(ChannelReader<T>, CancellationToken, Action<T>, Boolean)
  nameWithType: Extensions.ReadAll<T>(ChannelReader<T>, CancellationToken, Action<T>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken, System.Action<T>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 810
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<T>(this ChannelReader<T> reader, CancellationToken cancellationToken, Action<T> receiver, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Action{{T}}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken, receiver As Action(Of T), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken, System.Action(Of T), System.Boolean)
  name.vb: ReadAll(Of T)(ChannelReader(Of T), CancellationToken, Action(Of T), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Boolean,System.Threading.CancellationToken)
  id: ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead>, Boolean, CancellationToken)
  nameWithType: Extensions.ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Action<TRead>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 828
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<TWrite, TRead>(this Channel<TWrite, TRead> channel, Action<TRead> receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Action{{TRead}}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Action(Of TRead), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Action(Of TRead), System.Boolean, System.Threading.CancellationToken)
  name.vb: ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  id: ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Action{``1},System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead>, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, Action<TRead>, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Action<TRead>, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 850
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<TWrite, TRead>(this Channel<TWrite, TRead> channel, Action<TRead> receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: receiver
      type: System.Action{{TRead}}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), receiver As Action(Of TRead), cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead), CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Action(Of TRead), System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), Action(Of TRead), CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1},System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1},System.Boolean)
  id: ReadAll``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken,System.Action{``1},System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Action<TRead>, Boolean)
  nameWithType: Extensions.ReadAll<TWrite, TRead>(Channel<TWrite, TRead>, CancellationToken, Action<TRead>, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAll<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Threading.CancellationToken, System.Action<TRead>, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAll
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 867
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAll<TWrite, TRead>(this Channel<TWrite, TRead> channel, CancellationToken cancellationToken, Action<TRead> receiver, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The optional cancellation token.
    - id: receiver
      type: System.Action{{TRead}}
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAll(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), cancellationToken As CancellationToken, receiver As Action(Of TRead), deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAll*
  nameWithType.vb: Extensions.ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Action(Of TRead), Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAll(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Threading.CancellationToken, System.Action(Of TRead), System.Boolean)
  name.vb: ReadAll(Of TWrite, TRead)(Channel(Of TWrite, TRead), CancellationToken, Action(Of TRead), Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Boolean,System.Threading.CancellationToken)
  id: ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsLines(ChannelReader<String>, TextWriter, Boolean, CancellationToken)
  nameWithType: Extensions.ReadAllAsLines(ChannelReader<String>, TextWriter, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader<System.String>, System.IO.TextWriter, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsLines
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 883
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and writes to the target writer.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsLines(this ChannelReader<string> reader, TextWriter receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{System.String}
      description: The channel reader to read from.
    - id: receiver
      type: System.IO.TextWriter
      description: The receiver function.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsLines(reader As ChannelReader(Of String), receiver As TextWriter, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsLines*
  nameWithType.vb: Extensions.ReadAllAsLines(ChannelReader(Of String), TextWriter, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader(Of System.String), System.IO.TextWriter, System.Boolean, System.Threading.CancellationToken)
  name.vb: ReadAllAsLines(ChannelReader(Of String), TextWriter, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsLines(System.Threading.Channels.ChannelReader{System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsLines(ChannelReader<String>, TextWriter, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsLines(ChannelReader<String>, TextWriter, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader<System.String>, System.IO.TextWriter, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsLines
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 898
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and writes to the target writer.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsLines(this ChannelReader<string> reader, TextWriter receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{System.String}
      description: The channel reader to read from.
    - id: receiver
      type: System.IO.TextWriter
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsLines(reader As ChannelReader(Of String), receiver As TextWriter, cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsLines*
  nameWithType.vb: Extensions.ReadAllAsLines(ChannelReader(Of String), TextWriter, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsLines(System.Threading.Channels.ChannelReader(Of System.String), System.IO.TextWriter, System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsLines(ChannelReader(Of String), TextWriter, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Boolean,System.Threading.CancellationToken)
  id: ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsLines<T>(Channel<T, String>, TextWriter, Boolean, CancellationToken)
  nameWithType: Extensions.ReadAllAsLines<T>(Channel<T, String>, TextWriter, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsLines<T>(System.Threading.Channels.Channel<T, System.String>, System.IO.TextWriter, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsLines
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 914
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and writes to the target writer.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsLines<T>(this Channel<T, string> channel, TextWriter receiver, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{T},System.String}
      description: The channel to read from.
    - id: receiver
      type: System.IO.TextWriter
      description: The TextWriter to recieve the lines.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsLines(Of T)(channel As Channel(Of T, String), receiver As TextWriter, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsLines*
  nameWithType.vb: Extensions.ReadAllAsLines(Of T)(Channel(Of T, String), TextWriter, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsLines(Of T)(System.Threading.Channels.Channel(Of T, System.String), System.IO.TextWriter, System.Boolean, System.Threading.CancellationToken)
  name.vb: ReadAllAsLines(Of T)(Channel(Of T, String), TextWriter, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  id: ReadAllAsLines``1(System.Threading.Channels.Channel{``0,System.String},System.IO.TextWriter,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllAsLines<T>(Channel<T, String>, TextWriter, CancellationToken, Boolean)
  nameWithType: Extensions.ReadAllAsLines<T>(Channel<T, String>, TextWriter, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsLines<T>(System.Threading.Channels.Channel<T, System.String>, System.IO.TextWriter, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllAsLines
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 935
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and writes to the target writer.\n"
  example: []
  syntax:
    content: public static ValueTask<long> ReadAllAsLines<T>(this Channel<T, string> channel, TextWriter receiver, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{T},System.String}
      description: The channel to read from.
    - id: receiver
      type: System.IO.TextWriter
      description: The TextWriter to recieve the lines.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before reading.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        The count of items read after the reader has completed.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllAsLines(Of T)(channel As Channel(Of T, String), receiver As TextWriter, cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllAsLines*
  nameWithType.vb: Extensions.ReadAllAsLines(Of T)(Channel(Of T, String), TextWriter, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllAsLines(Of T)(System.Threading.Channels.Channel(Of T, System.String), System.IO.TextWriter, System.Threading.CancellationToken, System.Boolean)
  name.vb: ReadAllAsLines(Of T)(Channel(Of T, String), TextWriter, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ToListAsync``1(System.Threading.Channels.ChannelReader{``0})
  commentId: M:Open.ChannelExtensions.Extensions.ToListAsync``1(System.Threading.Channels.ChannelReader{``0})
  id: ToListAsync``1(System.Threading.Channels.ChannelReader{``0})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToListAsync<T>(ChannelReader<T>)
  nameWithType: Extensions.ToListAsync<T>(ChannelReader<T>)
  fullName: Open.ChannelExtensions.Extensions.ToListAsync<T>(System.Threading.Channels.ChannelReader<T>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Read.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToListAsync
    path: ../Open.ChannelExtensions/Extensions.Read.cs
    startLine: 948
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAdds all items in the reader to a list and returns when the channel completes.\nNote: this should only be used when the results of the channel are guaranteed to be limited.\n"
  example: []
  syntax:
    content: public static ValueTask<List<T>> ToListAsync<T>(this ChannelReader<T> reader)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.ValueTask{System.Collections.Generic.List{{T}}}
      description: A list containing all the items from the completed channel.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToListAsync(Of T)(reader As ChannelReader(Of T)) As ValueTask(Of List(Of T))
  overload: Open.ChannelExtensions.Extensions.ToListAsync*
  nameWithType.vb: Extensions.ToListAsync(Of T)(ChannelReader(Of T))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToListAsync(Of T)(System.Threading.Channels.ChannelReader(Of T))
  name.vb: ToListAsync(Of T)(ChannelReader(Of T))
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  id: ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrentlyAsync<T>(ChannelReader<T>, Int32, Func<T, ValueTask>, CancellationToken)
  nameWithType: Extensions.ReadAllConcurrentlyAsync<T>(ChannelReader<T>, Int32, Func<T, ValueTask>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Func<T, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrentlyAsync
    path: ../Open.ChannelExtensions/Extensions.ReadConcurrently.cs
    startLine: 20
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrentlyAsync<T>(this ChannelReader<T> reader, int maxConcurrency, Func<T, ValueTask> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrentlyAsync(Of T)(reader As ChannelReader(Of T), maxConcurrency As Integer, receiver As Func(Of T, ValueTask), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync*
  nameWithType.vb: Extensions.ReadAllConcurrentlyAsync(Of T)(ChannelReader(Of T), Int32, Func(Of T, ValueTask), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Func(Of T, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken)
  name.vb: ReadAllConcurrentlyAsync(Of T)(ChannelReader(Of T), Int32, Func(Of T, ValueTask), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask})
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask})
  id: ReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken,System.Func{``0,System.Threading.Tasks.ValueTask})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrentlyAsync<T>(ChannelReader<T>, Int32, CancellationToken, Func<T, ValueTask>)
  nameWithType: Extensions.ReadAllConcurrentlyAsync<T>(ChannelReader<T>, Int32, CancellationToken, Func<T, ValueTask>)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Threading.CancellationToken, System.Func<T, System.Threading.Tasks.ValueTask>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrentlyAsync
    path: ../Open.ChannelExtensions/Extensions.ReadConcurrently.cs
    startLine: 60
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrentlyAsync<T>(this ChannelReader<T> reader, int maxConcurrency, CancellationToken cancellationToken, Func<T, ValueTask> receiver)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrentlyAsync(Of T)(reader As ChannelReader(Of T), maxConcurrency As Integer, cancellationToken As CancellationToken, receiver As Func(Of T, ValueTask)) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync*
  nameWithType.vb: Extensions.ReadAllConcurrentlyAsync(Of T)(ChannelReader(Of T), Int32, CancellationToken, Func(Of T, ValueTask))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Threading.CancellationToken, System.Func(Of T, System.Threading.Tasks.ValueTask))
  name.vb: ReadAllConcurrentlyAsync(Of T)(ChannelReader(Of T), Int32, CancellationToken, Func(Of T, ValueTask))
- uid: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  id: TaskReadAllConcurrentlyAsync``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllConcurrentlyAsync<T>(ChannelReader<T>, Int32, Func<T, Task>, CancellationToken)
  nameWithType: Extensions.TaskReadAllConcurrentlyAsync<T>(ChannelReader<T>, Int32, Func<T, Task>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Func<T, System.Threading.Tasks.Task>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllConcurrentlyAsync
    path: ../Open.ChannelExtensions/Extensions.ReadConcurrently.cs
    startLine: 76
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> TaskReadAllConcurrentlyAsync<T>(this ChannelReader<T> reader, int maxConcurrency, Func<T, Task> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: receiver
      type: System.Func{{T},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllConcurrentlyAsync(Of T)(reader As ChannelReader(Of T), maxConcurrency As Integer, receiver As Func(Of T, Task), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync*
  nameWithType.vb: Extensions.TaskReadAllConcurrentlyAsync(Of T)(ChannelReader(Of T), Int32, Func(Of T, Task), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Func(Of T, System.Threading.Tasks.Task), System.Threading.CancellationToken)
  name.vb: TaskReadAllConcurrentlyAsync(Of T)(ChannelReader(Of T), Int32, Func(Of T, Task), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  id: ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrentlyAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Func<TRead, ValueTask>, CancellationToken)
  nameWithType: Extensions.ReadAllConcurrentlyAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Func<TRead, ValueTask>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Func<TRead, System.Threading.Tasks.ValueTask>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrentlyAsync
    path: ../Open.ChannelExtensions/Extensions.ReadConcurrently.cs
    startLine: 92
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrentlyAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, int maxConcurrency, Func<TRead, ValueTask> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrentlyAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), maxConcurrency As Integer, receiver As Func(Of TRead, ValueTask), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync*
  nameWithType.vb: Extensions.ReadAllConcurrentlyAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, ValueTask), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Func(Of TRead, System.Threading.Tasks.ValueTask), System.Threading.CancellationToken)
  name.vb: ReadAllConcurrentlyAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, ValueTask), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask})
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask})
  id: ReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Threading.CancellationToken,System.Func{``1,System.Threading.Tasks.ValueTask})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrentlyAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, CancellationToken, Func<TRead, ValueTask>)
  nameWithType: Extensions.ReadAllConcurrentlyAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, CancellationToken, Func<TRead, ValueTask>)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Threading.CancellationToken, System.Func<TRead, System.Threading.Tasks.ValueTask>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrentlyAsync
    path: ../Open.ChannelExtensions/Extensions.ReadConcurrently.cs
    startLine: 113
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrentlyAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, int maxConcurrency, CancellationToken cancellationToken, Func<TRead, ValueTask> receiver)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.ValueTask}
      description: The async receiver function.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrentlyAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), maxConcurrency As Integer, cancellationToken As CancellationToken, receiver As Func(Of TRead, ValueTask)) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync*
  nameWithType.vb: Extensions.ReadAllConcurrentlyAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, CancellationToken, Func(Of TRead, ValueTask))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Threading.CancellationToken, System.Func(Of TRead, System.Threading.Tasks.ValueTask))
  name.vb: ReadAllConcurrentlyAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, CancellationToken, Func(Of TRead, ValueTask))
- uid: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  id: TaskReadAllConcurrentlyAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Func{``1,System.Threading.Tasks.Task},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: TaskReadAllConcurrentlyAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Func<TRead, Task>, CancellationToken)
  nameWithType: Extensions.TaskReadAllConcurrentlyAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Func<TRead, Task>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Func<TRead, System.Threading.Tasks.Task>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: TaskReadAllConcurrentlyAsync
    path: ../Open.ChannelExtensions/Extensions.ReadConcurrently.cs
    startLine: 130
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> TaskReadAllConcurrentlyAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, int maxConcurrency, Func<TRead, Task> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: receiver
      type: System.Func{{TRead},System.Threading.Tasks.Task}
      description: The async receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function TaskReadAllConcurrentlyAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), maxConcurrency As Integer, receiver As Func(Of TRead, Task), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync*
  nameWithType.vb: Extensions.TaskReadAllConcurrentlyAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, Task), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Func(Of TRead, System.Threading.Tasks.Task), System.Threading.CancellationToken)
  name.vb: TaskReadAllConcurrentlyAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Func(Of TRead, Task), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Action{``0},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Action{``0},System.Threading.CancellationToken)
  id: ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Action{``0},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrently<T>(ChannelReader<T>, Int32, Action<T>, CancellationToken)
  nameWithType: Extensions.ReadAllConcurrently<T>(ChannelReader<T>, Int32, Action<T>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrently<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Action<T>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrently
    path: ../Open.ChannelExtensions/Extensions.ReadConcurrently.cs
    startLine: 150
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrently<T>(this ChannelReader<T> reader, int maxConcurrency, Action<T> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: receiver
      type: System.Action{{T}}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrently(Of T)(reader As ChannelReader(Of T), maxConcurrency As Integer, receiver As Action(Of T), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrently*
  nameWithType.vb: Extensions.ReadAllConcurrently(Of T)(ChannelReader(Of T), Int32, Action(Of T), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrently(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Action(Of T), System.Threading.CancellationToken)
  name.vb: ReadAllConcurrently(Of T)(ChannelReader(Of T), Int32, Action(Of T), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken,System.Action{``0})
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken,System.Action{``0})
  id: ReadAllConcurrently``1(System.Threading.Channels.ChannelReader{``0},System.Int32,System.Threading.CancellationToken,System.Action{``0})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrently<T>(ChannelReader<T>, Int32, CancellationToken, Action<T>)
  nameWithType: Extensions.ReadAllConcurrently<T>(ChannelReader<T>, Int32, CancellationToken, Action<T>)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrently<T>(System.Threading.Channels.ChannelReader<T>, System.Int32, System.Threading.CancellationToken, System.Action<T>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrently
    path: ../Open.ChannelExtensions/Extensions.ReadConcurrently.cs
    startLine: 171
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrently<T>(this ChannelReader<T> reader, int maxConcurrency, CancellationToken cancellationToken, Action<T> receiver)
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Action{{T}}
      description: The receiver function.
    typeParameters:
    - id: T
      description: The item type.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrently(Of T)(reader As ChannelReader(Of T), maxConcurrency As Integer, cancellationToken As CancellationToken, receiver As Action(Of T)) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrently*
  nameWithType.vb: Extensions.ReadAllConcurrently(Of T)(ChannelReader(Of T), Int32, CancellationToken, Action(Of T))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrently(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Int32, System.Threading.CancellationToken, System.Action(Of T))
  name.vb: ReadAllConcurrently(Of T)(ChannelReader(Of T), Int32, CancellationToken, Action(Of T))
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Action{``1},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Action{``1},System.Threading.CancellationToken)
  id: ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Action{``1},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrently<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Action<TRead>, CancellationToken)
  nameWithType: Extensions.ReadAllConcurrently<TWrite, TRead>(Channel<TWrite, TRead>, Int32, Action<TRead>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrently<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Action<TRead>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrently
    path: ../Open.ChannelExtensions/Extensions.ReadConcurrently.cs
    startLine: 188
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrently<TWrite, TRead>(this Channel<TWrite, TRead> channel, int maxConcurrency, Action<TRead> receiver, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: receiver
      type: System.Action{{TRead}}
      description: The receiver function.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrently(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), maxConcurrency As Integer, receiver As Action(Of TRead), cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrently*
  nameWithType.vb: Extensions.ReadAllConcurrently(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Action(Of TRead), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrently(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Action(Of TRead), System.Threading.CancellationToken)
  name.vb: ReadAllConcurrently(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, Action(Of TRead), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Threading.CancellationToken,System.Action{``1})
  commentId: M:Open.ChannelExtensions.Extensions.ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Threading.CancellationToken,System.Action{``1})
  id: ReadAllConcurrently``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Threading.CancellationToken,System.Action{``1})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ReadAllConcurrently<TWrite, TRead>(Channel<TWrite, TRead>, Int32, CancellationToken, Action<TRead>)
  nameWithType: Extensions.ReadAllConcurrently<TWrite, TRead>(Channel<TWrite, TRead>, Int32, CancellationToken, Action<TRead>)
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrently<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Threading.CancellationToken, System.Action<TRead>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.ReadConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ReadAllConcurrently
    path: ../Open.ChannelExtensions/Extensions.ReadConcurrently.cs
    startLine: 209
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nReads items from the channel and passes them to the receiver.\n"
  example: []
  syntax:
    content: public static Task<long> ReadAllConcurrently<TWrite, TRead>(this Channel<TWrite, TRead> channel, int maxConcurrency, CancellationToken cancellationToken, Action<TRead> receiver)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to read from.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: receiver
      type: System.Action{{TRead}}
      description: The receiver function.
    typeParameters:
    - id: TWrite
      description: The item type of the writer.
    - id: TRead
      description: The item type of the reader.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: A task that completes when no more reading is to be done.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ReadAllConcurrently(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), maxConcurrency As Integer, cancellationToken As CancellationToken, receiver As Action(Of TRead)) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.ReadAllConcurrently*
  nameWithType.vb: Extensions.ReadAllConcurrently(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, CancellationToken, Action(Of TRead))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ReadAllConcurrently(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Threading.CancellationToken, System.Action(Of TRead))
  name.vb: ReadAllConcurrently(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, CancellationToken, Action(Of TRead))
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Func<TWrite>>, Boolean, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Func<TWrite>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<System.Func<TWrite>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 22
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nExecutes all entries from the source and passes their result to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<Func<TWrite>> source, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{TWrite}}}
      description: The asynchronous source data to use.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of Func(Of TWrite)), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Func(Of TWrite)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of System.Func(Of TWrite)), System.Boolean, System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Func(Of TWrite)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Func<TWrite>>, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Func<TWrite>>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<System.Func<TWrite>>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 42
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nExecutes all entries from the source and passes their result to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<Func<TWrite>> source, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of Func(Of TWrite)), cancellationToken As CancellationToken) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Func(Of TWrite)), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of System.Func(Of TWrite)), System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Func(Of TWrite)), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<ValueTask<TWrite>>, Boolean, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<ValueTask<TWrite>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<TWrite>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 56
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<ValueTask<TWrite>> source, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{TWrite}}}
      description: The asynchronous source data to use.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of ValueTask(Of TWrite)), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of ValueTask(Of TWrite)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of TWrite)), System.Boolean, System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of ValueTask(Of TWrite)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<ValueTask<TWrite>>, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<ValueTask<TWrite>>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<TWrite>>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 76
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<ValueTask<TWrite>> source, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of ValueTask(Of TWrite)), cancellationToken As CancellationToken) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of ValueTask(Of TWrite)), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of TWrite)), System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of ValueTask(Of TWrite)), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Task<TWrite>>, Boolean, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Task<TWrite>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TWrite>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 90
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<Task<TWrite>> source, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{TWrite}}}
      description: The asynchronous source data to use.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of Task(Of TWrite)), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Task(Of TWrite)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of TWrite)), System.Boolean, System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Task(Of TWrite)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Task<TWrite>>, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<Task<TWrite>>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TWrite>>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 110
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<Task<TWrite>> source, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of Task(Of TWrite)), cancellationToken As CancellationToken) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Task(Of TWrite)), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of TWrite)), System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of Task(Of TWrite)), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  id: Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Source<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<TWrite>, Boolean, CancellationToken)
  nameWithType: Extensions.Source<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<TWrite>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Source<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<TWrite>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Source
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 124
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> Source<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<TWrite> source, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{{TWrite}}
      description: The source data to use.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Source(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of TWrite), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.Source*
  nameWithType.vb: Extensions.Source(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of TWrite), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Source(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of TWrite), System.Boolean, System.Threading.CancellationToken)
  name.vb: Source(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of TWrite), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)
  id: Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Source<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<TWrite>, CancellationToken)
  nameWithType: Extensions.Source<TWrite, TRead>(Channel<TWrite, TRead>, IEnumerable<TWrite>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Source<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IEnumerable<TWrite>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Source
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 144
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> Source<TWrite, TRead>(this Channel<TWrite, TRead> target, IEnumerable<TWrite> source, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{{TWrite}}
      description: The source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Source(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IEnumerable(Of TWrite), cancellationToken As CancellationToken) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.Source*
  nameWithType.vb: Extensions.Source(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of TWrite), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Source(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IEnumerable(Of TWrite), System.Threading.CancellationToken)
  name.vb: Source(Of TWrite, TRead)(Channel(Of TWrite, TRead), IEnumerable(Of TWrite), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<Func<TWrite>>, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<Func<TWrite>>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Collections.Generic.IEnumerable<System.Func<TWrite>>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 158
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nExecutes all entries from the source and passes their result to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, int maxConcurrency, IEnumerable<Func<TWrite>> source, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), maxConcurrency As Integer, source As IEnumerable(Of Func(Of TWrite)), cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of Func(Of TWrite)), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Collections.Generic.IEnumerable(Of System.Func(Of TWrite)), System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of Func(Of TWrite)), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<ValueTask<TWrite>>, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<ValueTask<TWrite>>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<TWrite>>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 181
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, int maxConcurrency, IEnumerable<ValueTask<TWrite>> source, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), maxConcurrency As Integer, source As IEnumerable(Of ValueTask(Of TWrite)), cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of ValueTask(Of TWrite)), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of TWrite)), System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of ValueTask(Of TWrite)), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  id: SourceAsync``2(System.Threading.Channels.Channel{``0,``1},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<Task<TWrite>>, CancellationToken)
  nameWithType: Extensions.SourceAsync<TWrite, TRead>(Channel<TWrite, TRead>, Int32, IEnumerable<Task<TWrite>>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.SourceAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Int32, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TWrite>>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: SourceAsync
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 207
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> SourceAsync<TWrite, TRead>(this Channel<TWrite, TRead> target, int maxConcurrency, IEnumerable<Task<TWrite>> source, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{TWrite}}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function SourceAsync(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), maxConcurrency As Integer, source As IEnumerable(Of Task(Of TWrite)), cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.SourceAsync*
  nameWithType.vb: Extensions.SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of Task(Of TWrite)), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.SourceAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Int32, System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of TWrite)), System.Threading.CancellationToken)
  name.vb: SourceAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Int32, IEnumerable(Of Task(Of TWrite)), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken)
  id: Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Source<T>(Channel<String, T>, TextReader, Boolean, CancellationToken)
  nameWithType: Extensions.Source<T>(Channel<String, T>, TextReader, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Source<T>(System.Threading.Channels.Channel<System.String, T>, System.IO.TextReader, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Source
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 232
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Source<T>(this Channel<string, T> target, TextReader source, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{System.String,{T}}
      description: The channel to write to.
    - id: source
      type: System.IO.TextReader
      description: The source data to use.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Source(Of T)(target As Channel(Of String, T), source As TextReader, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Source*
  nameWithType.vb: Extensions.Source(Of T)(Channel(Of String, T), TextReader, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Source(Of T)(System.Threading.Channels.Channel(Of System.String, T), System.IO.TextReader, System.Boolean, System.Threading.CancellationToken)
  name.vb: Source(Of T)(Channel(Of String, T), TextReader, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Threading.CancellationToken)
  id: Source``1(System.Threading.Channels.Channel{System.String,``0},System.IO.TextReader,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Source<T>(Channel<String, T>, TextReader, CancellationToken)
  nameWithType: Extensions.Source<T>(Channel<String, T>, TextReader, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Source<T>(System.Threading.Channels.Channel<System.String, T>, System.IO.TextReader, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Source
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 253
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> Source<T>(this Channel<string, T> target, TextReader source, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{System.String,{T}}
      description: The channel to write to.
    - id: source
      type: System.IO.TextReader
      description: The source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    typeParameters:
    - id: T
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Source(Of T)(target As Channel(Of String, T), source As TextReader, cancellationToken As CancellationToken) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.Source*
  nameWithType.vb: Extensions.Source(Of T)(Channel(Of String, T), TextReader, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Source(Of T)(System.Threading.Channels.Channel(Of System.String, T), System.IO.TextReader, System.Threading.CancellationToken)
  name.vb: Source(Of T)(Channel(Of String, T), TextReader, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  id: Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Source<TWrite, TRead>(Channel<TWrite, TRead>, IAsyncEnumerable<TWrite>, Boolean, CancellationToken)
  nameWithType: Extensions.Source<TWrite, TRead>(Channel<TWrite, TRead>, IAsyncEnumerable<TWrite>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Source<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IAsyncEnumerable<TWrite>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Source
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 268
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nExecutes all entries from the source and passes their result to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> Source<TWrite, TRead>(this Channel<TWrite, TRead> target, IAsyncEnumerable<TWrite> source, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IAsyncEnumerable{{TWrite}}
      description: The asynchronous source data to use.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Source(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IAsyncEnumerable(Of TWrite), deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.Source*
  nameWithType.vb: Extensions.Source(Of TWrite, TRead)(Channel(Of TWrite, TRead), IAsyncEnumerable(Of TWrite), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Source(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IAsyncEnumerable(Of TWrite), System.Boolean, System.Threading.CancellationToken)
  name.vb: Source(Of TWrite, TRead)(Channel(Of TWrite, TRead), IAsyncEnumerable(Of TWrite), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)
  id: Source``2(System.Threading.Channels.Channel{``0,``1},System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Source<TWrite, TRead>(Channel<TWrite, TRead>, IAsyncEnumerable<TWrite>, CancellationToken)
  nameWithType: Extensions.Source<TWrite, TRead>(Channel<TWrite, TRead>, IAsyncEnumerable<TWrite>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.Source<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Collections.Generic.IAsyncEnumerable<TWrite>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Source.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Source
    path: ../Open.ChannelExtensions/Extensions.Source.cs
    startLine: 290
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nExecutes all entries from the source and passes their result to the channel.  Calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<TRead> Source<TWrite, TRead>(this Channel<TWrite, TRead> target, IAsyncEnumerable<TWrite> source, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IAsyncEnumerable{{TWrite}}
      description: The asynchronous source data to use.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    typeParameters:
    - id: TWrite
      description: The input type of the channel.
    - id: TRead
      description: The output type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{TRead}}
      description: The channel reader.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Source(Of TWrite, TRead)(target As Channel(Of TWrite, TRead), source As IAsyncEnumerable(Of TWrite), cancellationToken As CancellationToken) As ChannelReader(Of TRead)
  overload: Open.ChannelExtensions.Extensions.Source*
  nameWithType.vb: Extensions.Source(Of TWrite, TRead)(Channel(Of TWrite, TRead), IAsyncEnumerable(Of TWrite), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Source(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Collections.Generic.IAsyncEnumerable(Of TWrite), System.Threading.CancellationToken)
  name.vb: Source(Of TWrite, TRead)(Channel(Of TWrite, TRead), IAsyncEnumerable(Of TWrite), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.Transform``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1})
  commentId: M:Open.ChannelExtensions.Extensions.Transform``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1})
  id: Transform``2(System.Threading.Channels.ChannelReader{``0},System.Func{``0,``1})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Transform<T, TResult>(ChannelReader<T>, Func<T, TResult>)
  nameWithType: Extensions.Transform<T, TResult>(ChannelReader<T>, Func<T, TResult>)
  fullName: Open.ChannelExtensions.Extensions.Transform<T, TResult>(System.Threading.Channels.ChannelReader<T>, System.Func<T, TResult>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Transform.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Transform
    path: ../Open.ChannelExtensions/Extensions.Transform.cs
    startLine: 50
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nTransforms the \n"
  example: []
  syntax:
    content: public static ChannelReader<TResult> Transform<T, TResult>(this ChannelReader<T> source, Func<T, TResult> transform)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The source channel reader.
    - id: transform
      type: System.Func{{T},{TResult}}
      description: The transform function.
    typeParameters:
    - id: T
      description: The output type of the provided source reader and input type of the transform.
    - id: TResult
      description: The output type of the transform.
    return:
      type: System.Threading.Channels.ChannelReader{{TResult}}
      description: A channel reader representing the tranformed results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Transform(Of T, TResult)(source As ChannelReader(Of T), transform As Func(Of T, TResult)) As ChannelReader(Of TResult)
  overload: Open.ChannelExtensions.Extensions.Transform*
  nameWithType.vb: Extensions.Transform(Of T, TResult)(ChannelReader(Of T), Func(Of T, TResult))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Transform(Of T, TResult)(System.Threading.Channels.ChannelReader(Of T), System.Func(Of T, TResult))
  name.vb: Transform(Of T, TResult)(ChannelReader(Of T), Func(Of T, TResult))
- uid: Open.ChannelExtensions.Extensions.Transform``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2})
  commentId: M:Open.ChannelExtensions.Extensions.Transform``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2})
  id: Transform``3(System.Threading.Channels.Channel{``0,``1},System.Func{``1,``2})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Transform<TWrite, TRead, TResult>(Channel<TWrite, TRead>, Func<TRead, TResult>)
  nameWithType: Extensions.Transform<TWrite, TRead, TResult>(Channel<TWrite, TRead>, Func<TRead, TResult>)
  fullName: Open.ChannelExtensions.Extensions.Transform<TWrite, TRead, TResult>(System.Threading.Channels.Channel<TWrite, TRead>, System.Func<TRead, TResult>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Transform.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Transform
    path: ../Open.ChannelExtensions/Extensions.Transform.cs
    startLine: 62
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nTransforms the \n"
  example: []
  syntax:
    content: public static TransformChannel<TWrite, TRead, TResult> Transform<TWrite, TRead, TResult>(this Channel<TWrite, TRead> source, Func<TRead, TResult> transform)
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The source channel reader.
    - id: transform
      type: System.Func{{TRead},{TResult}}
      description: The transform function.
    typeParameters:
    - id: TWrite
      description: Specifies the type of data that may be written to the channel.
    - id: TRead
      description: Specifies the type of data read from the source channel.
    - id: TResult
      description: Specifies the type of data that may be read from the channel.
    return:
      type: Open.ChannelExtensions.TransformChannel{{TWrite},{TRead},{TResult}}
      description: A channel reader representing the tranformed results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Transform(Of TWrite, TRead, TResult)(source As Channel(Of TWrite, TRead), transform As Func(Of TRead, TResult)) As TransformChannel(Of TWrite, TRead, TResult)
  overload: Open.ChannelExtensions.Extensions.Transform*
  nameWithType.vb: Extensions.Transform(Of TWrite, TRead, TResult)(Channel(Of TWrite, TRead), Func(Of TRead, TResult))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Transform(Of TWrite, TRead, TResult)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Func(Of TRead, TResult))
  name.vb: Transform(Of TWrite, TRead, TResult)(Channel(Of TWrite, TRead), Func(Of TRead, TResult))
- uid: Open.ChannelExtensions.Extensions.Transform``2(System.Threading.Channels.Channel{``0},System.Func{``0,``1})
  commentId: M:Open.ChannelExtensions.Extensions.Transform``2(System.Threading.Channels.Channel{``0},System.Func{``0,``1})
  id: Transform``2(System.Threading.Channels.Channel{``0},System.Func{``0,``1})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: Transform<T, TResult>(Channel<T>, Func<T, TResult>)
  nameWithType: Extensions.Transform<T, TResult>(Channel<T>, Func<T, TResult>)
  fullName: Open.ChannelExtensions.Extensions.Transform<T, TResult>(System.Threading.Channels.Channel<T>, System.Func<T, TResult>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Transform.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: Transform
    path: ../Open.ChannelExtensions/Extensions.Transform.cs
    startLine: 73
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nTransforms the \n"
  example: []
  syntax:
    content: public static TransformChannel<T, TResult> Transform<T, TResult>(this Channel<T> source, Func<T, TResult> transform)
    parameters:
    - id: source
      type: System.Threading.Channels.Channel{{T}}
      description: The source channel reader.
    - id: transform
      type: System.Func{{T},{TResult}}
      description: The transform function.
    typeParameters:
    - id: T
      description: Specifies the type of data that may be written to the channel.
    - id: TResult
      description: Specifies the type of data that may be read from the channel.
    return:
      type: Open.ChannelExtensions.TransformChannel{{T},{TResult}}
      description: A channel reader representing the tranformed results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function Transform(Of T, TResult)(source As Channel(Of T), transform As Func(Of T, TResult)) As TransformChannel(Of T, TResult)
  overload: Open.ChannelExtensions.Extensions.Transform*
  nameWithType.vb: Extensions.Transform(Of T, TResult)(Channel(Of T), Func(Of T, TResult))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.Transform(Of T, TResult)(System.Threading.Channels.Channel(Of T), System.Func(Of T, TResult))
  name.vb: Transform(Of T, TResult)(Channel(Of T), Func(Of T, TResult))
- uid: Open.ChannelExtensions.Extensions.OfType``2(System.Threading.Channels.ChannelReader{``0})
  commentId: M:Open.ChannelExtensions.Extensions.OfType``2(System.Threading.Channels.ChannelReader{``0})
  id: OfType``2(System.Threading.Channels.ChannelReader{``0})
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: OfType<TSource, T>(ChannelReader<TSource>)
  nameWithType: Extensions.OfType<TSource, T>(ChannelReader<TSource>)
  fullName: Open.ChannelExtensions.Extensions.OfType<TSource, T>(System.Threading.Channels.ChannelReader<TSource>)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.TypeFilter.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: OfType
    path: ../Open.ChannelExtensions/Extensions.TypeFilter.cs
    startLine: 47
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nProduces a reader that only contains results of a specific type.  Others are discarded.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> OfType<TSource, T>(this ChannelReader<TSource> source)
    parameters:
    - id: source
      type: System.Threading.Channels.ChannelReader{{TSource}}
      description: The source channel reader.
    typeParameters:
    - id: TSource
      description: The source item type.
    - id: T
      description: The desired item type.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: A channel reader representing the filtered results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function OfType(Of TSource, T)(source As ChannelReader(Of TSource)) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.OfType*
  nameWithType.vb: Extensions.OfType(Of TSource, T)(ChannelReader(Of TSource))
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.OfType(Of TSource, T)(System.Threading.Channels.ChannelReader(Of TSource))
  name.vb: OfType(Of TSource, T)(ChannelReader(Of TSource))
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<ValueTask<T>>, Boolean, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<ValueTask<T>>, Boolean, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<T>>, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 26
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IEnumerable<ValueTask<T>> source, bool complete = false, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of ValueTask(Of T)), complete As Boolean = False, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of ValueTask(Of T)), Boolean, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of T)), System.Boolean, System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of ValueTask(Of T)), Boolean, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<ValueTask<T>>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<ValueTask<T>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<T>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 75
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IEnumerable<ValueTask<T>> source, bool complete, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of ValueTask(Of T)), complete As Boolean, cancellationToken As CancellationToken) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of ValueTask(Of T)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of T)), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of ValueTask(Of T)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Task<T>>, Boolean, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Task<T>>, Boolean, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<T>>, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 90
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IEnumerable<Task<T>> source, bool complete = false, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of Task(Of T)), complete As Boolean = False, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Task(Of T)), Boolean, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of T)), System.Boolean, System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Task(Of T)), Boolean, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Task<T>>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Task<T>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<T>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 110
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IEnumerable<Task<T>> source, bool complete, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of Task(Of T)), complete As Boolean, cancellationToken As CancellationToken) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Task(Of T)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of T)), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Task(Of T)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Func<T>>, Boolean, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Func<T>>, Boolean, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<System.Func<T>>, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 125
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously executes all entries and writes their results to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IEnumerable<Func<T>> source, bool complete = false, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of Func(Of T)), complete As Boolean = False, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Func(Of T)), Boolean, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of System.Func(Of T)), System.Boolean, System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Func(Of T)), Boolean, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Func<T>>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IEnumerable<Func<T>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<System.Func<T>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 145
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously executes all entries and writes their results to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IEnumerable<Func<T>> source, bool complete, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of Func(Of T)), complete As Boolean, cancellationToken As CancellationToken) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Func(Of T)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of System.Func(Of T)), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IEnumerable(Of Func(Of T)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  id: WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAll<T>(ChannelWriter<T>, IEnumerable<T>, Boolean, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAll<T>(ChannelWriter<T>, IEnumerable<T>, Boolean, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAll<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<T>, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAll
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 160
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAll<T>(this ChannelWriter<T> target, IEnumerable<T> source, bool complete = false, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{{T}}
      description: The source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAll(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of T), complete As Boolean = False, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAll*
  nameWithType.vb: Extensions.WriteAll(Of T)(ChannelWriter(Of T), IEnumerable(Of T), Boolean, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAll(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of T), System.Boolean, System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAll(Of T)(ChannelWriter(Of T), IEnumerable(Of T), Boolean, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  id: WriteAll``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAll<T>(ChannelWriter<T>, IEnumerable<T>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAll<T>(ChannelWriter<T>, IEnumerable<T>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAll<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IEnumerable<T>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAll
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 180
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAll<T>(this ChannelWriter<T> target, IEnumerable<T> source, bool complete, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IEnumerable{{T}}
      description: The source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAll(Of T)(target As ChannelWriter(Of T), source As IEnumerable(Of T), complete As Boolean, cancellationToken As CancellationToken) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAll*
  nameWithType.vb: Extensions.WriteAll(Of T)(ChannelWriter(Of T), IEnumerable(Of T), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAll(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IEnumerable(Of T), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAll(Of T)(ChannelWriter(Of T), IEnumerable(Of T), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  id: WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllLines(ChannelWriter<String>, TextReader, Boolean, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllLines(ChannelWriter<String>, TextReader, Boolean, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter<System.String>, System.IO.TextReader, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllLines
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 194
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nConsumes all lines from a TextReader and writes them to a channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllLines(this ChannelWriter<string> target, TextReader source, bool complete = false, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{System.String}
      description: The channel to write to.
    - id: source
      type: System.IO.TextReader
      description: The text reader to consume from.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllLines(target As ChannelWriter(Of String), source As TextReader, complete As Boolean = False, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllLines*
  nameWithType.vb: Extensions.WriteAllLines(ChannelWriter(Of String), TextReader, Boolean, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter(Of System.String), System.IO.TextReader, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllLines(ChannelWriter(Of String), TextReader, Boolean, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken)
  id: WriteAllLines(System.Threading.Channels.ChannelWriter{System.String},System.IO.TextReader,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllLines(ChannelWriter<String>, TextReader, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllLines(ChannelWriter<String>, TextReader, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter<System.String>, System.IO.TextReader, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllLines
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 254
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nConsumes all lines from a TextReader and writes them to a channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllLines(this ChannelWriter<string> target, TextReader source, bool complete, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{System.String}
      description: The channel to write to.
    - id: source
      type: System.IO.TextReader
      description: The text reader to consume from.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllLines(target As ChannelWriter(Of String), source As TextReader, complete As Boolean, cancellationToken As CancellationToken) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllLines*
  nameWithType.vb: Extensions.WriteAllLines(ChannelWriter(Of String), TextReader, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllLines(System.Threading.Channels.ChannelWriter(Of System.String), System.IO.TextReader, System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllLines(ChannelWriter(Of String), TextReader, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IAsyncEnumerable<T>, Boolean, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IAsyncEnumerable<T>, Boolean, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IAsyncEnumerable<T>, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 270
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IAsyncEnumerable<T> source, bool complete = false, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IAsyncEnumerable{{T}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IAsyncEnumerable(Of T), complete As Boolean = False, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IAsyncEnumerable(Of T), Boolean, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IAsyncEnumerable(Of T), System.Boolean, System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IAsyncEnumerable(Of T), Boolean, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  id: WriteAllAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Collections.Generic.IAsyncEnumerable{``0},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllAsync<T>(ChannelWriter<T>, IAsyncEnumerable<T>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllAsync<T>(ChannelWriter<T>, IAsyncEnumerable<T>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Collections.Generic.IAsyncEnumerable<T>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.Write.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllAsync
    path: ../Open.ChannelExtensions/Extensions.Write.cs
    startLine: 320
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static ValueTask<long> WriteAllAsync<T>(this ChannelWriter<T> target, IAsyncEnumerable<T> source, bool complete, CancellationToken cancellationToken)
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: source
      type: System.Collections.Generic.IAsyncEnumerable{{T}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.ValueTask{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllAsync(Of T)(target As ChannelWriter(Of T), source As IAsyncEnumerable(Of T), complete As Boolean, cancellationToken As CancellationToken) As ValueTask(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllAsync*
  nameWithType.vb: Extensions.WriteAllAsync(Of T)(ChannelWriter(Of T), IAsyncEnumerable(Of T), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Collections.Generic.IAsyncEnumerable(Of T), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllAsync(Of T)(ChannelWriter(Of T), IAsyncEnumerable(Of T), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  id: WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<ValueTask<T>>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<ValueTask<T>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Int32, System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<T>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.WriteConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllConcurrentlyAsync
    path: ../Open.ChannelExtensions/Extensions.WriteConcurrently.cs
    startLine: 23
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static Task<long> WriteAllConcurrentlyAsync<T>(this ChannelWriter<T> target, int maxConcurrency, IEnumerable<ValueTask<T>> source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllConcurrentlyAsync(Of T)(target As ChannelWriter(Of T), maxConcurrency As Integer, source As IEnumerable(Of ValueTask(Of T)), complete As Boolean = False, cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync*
  nameWithType.vb: Extensions.WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of ValueTask(Of T)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Int32, System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of T)), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of ValueTask(Of T)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  id: WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<Task<T>>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<Task<T>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Int32, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<T>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.WriteConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllConcurrentlyAsync
    path: ../Open.ChannelExtensions/Extensions.WriteConcurrently.cs
    startLine: 115
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously writes all entries from the source to the channel.\n"
  example: []
  syntax:
    content: public static Task<long> WriteAllConcurrentlyAsync<T>(this ChannelWriter<T> target, int maxConcurrency, IEnumerable<Task<T>> source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllConcurrentlyAsync(Of T)(target As ChannelWriter(Of T), maxConcurrency As Integer, source As IEnumerable(Of Task(Of T)), complete As Boolean = False, cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync*
  nameWithType.vb: Extensions.WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of Task(Of T)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Int32, System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of T)), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of Task(Of T)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  id: WriteAllConcurrentlyAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Int32,System.Collections.Generic.IEnumerable{System.Func{``0}},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<Func<T>>, Boolean, CancellationToken)
  nameWithType: Extensions.WriteAllConcurrentlyAsync<T>(ChannelWriter<T>, Int32, IEnumerable<Func<T>>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Int32, System.Collections.Generic.IEnumerable<System.Func<T>>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions.WriteConcurrently.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WriteAllConcurrentlyAsync
    path: ../Open.ChannelExtensions/Extensions.WriteConcurrently.cs
    startLine: 130
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously executes all entries and writes their results to the channel.\n"
  example: []
  syntax:
    content: public static Task<long> WriteAllConcurrentlyAsync<T>(this ChannelWriter<T> target, int maxConcurrency, IEnumerable<Func<T>> source, bool complete = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: target
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel to write to.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{T}}}
      description: The asynchronous source data to use.
    - id: complete
      type: System.Boolean
      description: If true, will call .Complete() if all the results have successfully been written (or the source is emtpy).
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Tasks.Task{System.Int64}
      description: >-
        A task containing the count of items written that completes when all the data has been written to the channel writer.

        The count should be ignored if the number of iterations could exceed the max value of long.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WriteAllConcurrentlyAsync(Of T)(target As ChannelWriter(Of T), maxConcurrency As Integer, source As IEnumerable(Of Func(Of T)), complete As Boolean = False, cancellationToken As CancellationToken = Nothing) As Task(Of Long)
  overload: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync*
  nameWithType.vb: Extensions.WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of Func(Of T)), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Int32, System.Collections.Generic.IEnumerable(Of System.Func(Of T)), System.Boolean, System.Threading.CancellationToken)
  name.vb: WriteAllConcurrentlyAsync(Of T)(ChannelWriter(Of T), Int32, IEnumerable(Of Func(Of T)), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Threading.CancellationToken)
  id: WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, String, CancellationToken)
  nameWithType: Extensions.WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, String, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.String, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WaitToWriteAndThrowIfClosedAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 55
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWaits for opportunity to write to a channel and throws a ChannelClosedException if the channel is closed.  \n"
  example: []
  syntax:
    content: public static ValueTask WaitToWriteAndThrowIfClosedAsync<T>(this ChannelWriter<T> writer, string ifClosedMessage = null, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: writer
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel writer.
    - id: ifClosedMessage
      type: System.String
      description: The message to include with the ChannelClosedException if thrown.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The type being written to the channel
    return:
      type: System.Threading.Tasks.ValueTask
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WaitToWriteAndThrowIfClosedAsync(Of T)(writer As ChannelWriter(Of T), ifClosedMessage As String = Nothing, cancellationToken As CancellationToken = Nothing) As ValueTask
  overload: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync*
  nameWithType.vb: Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), String, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.String, System.Threading.CancellationToken)
  name.vb: WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), String, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Boolean,System.Threading.CancellationToken)
  id: WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.String,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, String, Boolean, CancellationToken)
  nameWithType: Extensions.WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, String, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.String, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WaitToWriteAndThrowIfClosedAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 82
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWaits for opportunity to write to a channel and throws a ChannelClosedException if the channel is closed.  \n"
  example: []
  syntax:
    content: public static ValueTask WaitToWriteAndThrowIfClosedAsync<T>(this ChannelWriter<T> writer, string ifClosedMessage, bool deferredExecution, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: writer
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel writer.
    - id: ifClosedMessage
      type: System.String
      description: The message to include with the ChannelClosedException if thrown.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before continuing.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The type being written to the channel
    return:
      type: System.Threading.Tasks.ValueTask
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WaitToWriteAndThrowIfClosedAsync(Of T)(writer As ChannelWriter(Of T), ifClosedMessage As String, deferredExecution As Boolean, cancellationToken As CancellationToken = Nothing) As ValueTask
  overload: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync*
  nameWithType.vb: Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), String, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.String, System.Boolean, System.Threading.CancellationToken)
  name.vb: WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), String, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Threading.CancellationToken)
  id: WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, CancellationToken)
  nameWithType: Extensions.WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WaitToWriteAndThrowIfClosedAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 102
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWaits for opportunity to write to a channel and throws a ChannelClosedException if the channel is closed.  \n"
  example: []
  syntax:
    content: public static ValueTask WaitToWriteAndThrowIfClosedAsync<T>(this ChannelWriter<T> writer, CancellationToken cancellationToken)
    parameters:
    - id: writer
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel writer.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The type being written to the channel
    return:
      type: System.Threading.Tasks.ValueTask
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WaitToWriteAndThrowIfClosedAsync(Of T)(writer As ChannelWriter(Of T), cancellationToken As CancellationToken) As ValueTask
  overload: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync*
  nameWithType.vb: Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Threading.CancellationToken)
  name.vb: WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  id: WaitToWriteAndThrowIfClosedAsync``1(System.Threading.Channels.ChannelWriter{``0},System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, Boolean, CancellationToken)
  nameWithType: Extensions.WaitToWriteAndThrowIfClosedAsync<T>(ChannelWriter<T>, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync<T>(System.Threading.Channels.ChannelWriter<T>, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: WaitToWriteAndThrowIfClosedAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 112
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWaits for opportunity to write to a channel and throws a ChannelClosedException if the channel is closed.  \n"
  example: []
  syntax:
    content: public static ValueTask WaitToWriteAndThrowIfClosedAsync<T>(this ChannelWriter<T> writer, bool deferredExecution, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: writer
      type: System.Threading.Channels.ChannelWriter{{T}}
      description: The channel writer.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before continuing.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The type being written to the channel
    return:
      type: System.Threading.Tasks.ValueTask
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function WaitToWriteAndThrowIfClosedAsync(Of T)(writer As ChannelWriter(Of T), deferredExecution As Boolean, cancellationToken As CancellationToken = Nothing) As ValueTask
  overload: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync*
  nameWithType.vb: Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync(Of T)(System.Threading.Channels.ChannelWriter(Of T), System.Boolean, System.Threading.CancellationToken)
  name.vb: WaitToWriteAndThrowIfClosedAsync(Of T)(ChannelWriter(Of T), Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.CompleteAsync``2(System.Threading.Channels.Channel{``0,``1},System.Exception)
  commentId: M:Open.ChannelExtensions.Extensions.CompleteAsync``2(System.Threading.Channels.Channel{``0,``1},System.Exception)
  id: CompleteAsync``2(System.Threading.Channels.Channel{``0,``1},System.Exception)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: CompleteAsync<TWrite, TRead>(Channel<TWrite, TRead>, Exception)
  nameWithType: Extensions.CompleteAsync<TWrite, TRead>(Channel<TWrite, TRead>, Exception)
  fullName: Open.ChannelExtensions.Extensions.CompleteAsync<TWrite, TRead>(System.Threading.Channels.Channel<TWrite, TRead>, System.Exception)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: CompleteAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 134
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nCalls complete on the writer and returns the completion from the reader.\n"
  example: []
  syntax:
    content: public static Task CompleteAsync<TWrite, TRead>(this Channel<TWrite, TRead> channel, Exception exception = null)
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TWrite},{TRead}}
      description: The channel to complete asynchronously.
    - id: exception
      type: System.Exception
      description: The optional exception to include with completion.
    typeParameters:
    - id: TWrite
      description: The type being received by the writer.
    - id: TRead
      description: The type being read from the reader.
    return:
      type: System.Threading.Tasks.Task
      description: The reader&apos;s completion task.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function CompleteAsync(Of TWrite, TRead)(channel As Channel(Of TWrite, TRead), exception As Exception = Nothing) As Task
  overload: Open.ChannelExtensions.Extensions.CompleteAsync*
  nameWithType.vb: Extensions.CompleteAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Exception)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.CompleteAsync(Of TWrite, TRead)(System.Threading.Channels.Channel(Of TWrite, TRead), System.Exception)
  name.vb: CompleteAsync(Of TWrite, TRead)(Channel(Of TWrite, TRead), Exception)
- uid: Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  id: ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannel(TextReader, Int32, Boolean, Boolean, CancellationToken)
  nameWithType: Extensions.ToChannel(TextReader, Int32, Boolean, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader, System.Int32, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannel
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 152
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all lines from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<string> ToChannel(this TextReader source, int capacity = -1, bool singleReader = false, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.IO.TextReader
      description: The source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    return:
      type: System.Threading.Channels.ChannelReader{System.String}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannel(source As TextReader, capacity As Integer = -1, singleReader As Boolean = False, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of String)
  overload: Open.ChannelExtensions.Extensions.ToChannel*
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  id: ToChannel(System.IO.TextReader,System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannel(TextReader, Int32, Boolean, CancellationToken, Boolean)
  nameWithType: Extensions.ToChannel(TextReader, Int32, Boolean, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ToChannel(System.IO.TextReader, System.Int32, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannel
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 168
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all lines from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<string> ToChannel(this TextReader source, int capacity, bool singleReader, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: source
      type: System.IO.TextReader
      description: The source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    return:
      type: System.Threading.Channels.ChannelReader{System.String}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannel(source As TextReader, capacity As Integer, singleReader As Boolean, cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ChannelReader(Of String)
  overload: Open.ChannelExtensions.Extensions.ToChannel*
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Channels.ChannelOptions,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Channels.ChannelOptions,System.Boolean,System.Threading.CancellationToken)
  id: ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Channels.ChannelOptions,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannel<T>(IEnumerable<T>, ChannelOptions, Boolean, CancellationToken)
  nameWithType: Extensions.ToChannel<T>(IEnumerable<T>, ChannelOptions, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannel<T>(System.Collections.Generic.IEnumerable<T>, System.Threading.Channels.ChannelOptions, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannel
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 184
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannel<T>(this IEnumerable<T> source, ChannelOptions channelOptions, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{{T}}
      description: The source data to use.
    - id: channelOptions
      type: System.Threading.Channels.ChannelOptions
      description: The options for configuring the new channel.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannel(Of T)(source As IEnumerable(Of T), channelOptions As ChannelOptions, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannel*
  nameWithType.vb: Extensions.ToChannel(Of T)(IEnumerable(Of T), ChannelOptions, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannel(Of T)(System.Collections.Generic.IEnumerable(Of T), System.Threading.Channels.ChannelOptions, System.Boolean, System.Threading.CancellationToken)
  name.vb: ToChannel(Of T)(IEnumerable(Of T), ChannelOptions, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  id: ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannel<T>(IEnumerable<T>, Int32, Boolean, Boolean, CancellationToken)
  nameWithType: Extensions.ToChannel<T>(IEnumerable<T>, Int32, Boolean, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannel<T>(System.Collections.Generic.IEnumerable<T>, System.Int32, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannel
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 201
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannel<T>(this IEnumerable<T> source, int capacity = -1, bool singleReader = false, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{{T}}
      description: The source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannel(Of T)(source As IEnumerable(Of T), capacity As Integer = -1, singleReader As Boolean = False, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannel*
  nameWithType.vb: Extensions.ToChannel(Of T)(IEnumerable(Of T), Int32, Boolean, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannel(Of T)(System.Collections.Generic.IEnumerable(Of T), System.Int32, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  name.vb: ToChannel(Of T)(IEnumerable(Of T), Int32, Boolean, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  id: ToChannel``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannel<T>(IEnumerable<T>, Int32, Boolean, CancellationToken, Boolean)
  nameWithType: Extensions.ToChannel<T>(IEnumerable<T>, Int32, Boolean, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ToChannel<T>(System.Collections.Generic.IEnumerable<T>, System.Int32, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannel
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 218
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannel<T>(this IEnumerable<T> source, int capacity, bool singleReader, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{{T}}
      description: The source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannel(Of T)(source As IEnumerable(Of T), capacity As Integer, singleReader As Boolean, cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannel*
  nameWithType.vb: Extensions.ToChannel(Of T)(IEnumerable(Of T), Int32, Boolean, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannel(Of T)(System.Collections.Generic.IEnumerable(Of T), System.Int32, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  name.vb: ToChannel(Of T)(IEnumerable(Of T), Int32, Boolean, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  id: ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Int32,System.Boolean,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannel<T>(IAsyncEnumerable<T>, Int32, Boolean, Boolean, CancellationToken)
  nameWithType: Extensions.ToChannel<T>(IAsyncEnumerable<T>, Int32, Boolean, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannel<T>(System.Collections.Generic.IAsyncEnumerable<T>, System.Int32, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannel
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 236
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannel<T>(this IAsyncEnumerable<T> source, int capacity = -1, bool singleReader = false, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IAsyncEnumerable{{T}}
      description: The source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannel(Of T)(source As IAsyncEnumerable(Of T), capacity As Integer = -1, singleReader As Boolean = False, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannel*
  nameWithType.vb: Extensions.ToChannel(Of T)(IAsyncEnumerable(Of T), Int32, Boolean, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannel(Of T)(System.Collections.Generic.IAsyncEnumerable(Of T), System.Int32, System.Boolean, System.Boolean, System.Threading.CancellationToken)
  name.vb: ToChannel(Of T)(IAsyncEnumerable(Of T), Int32, Boolean, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.Channels.ChannelOptions,System.Boolean,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.Channels.ChannelOptions,System.Boolean,System.Threading.CancellationToken)
  id: ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Threading.Channels.ChannelOptions,System.Boolean,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannel<T>(IAsyncEnumerable<T>, ChannelOptions, Boolean, CancellationToken)
  nameWithType: Extensions.ToChannel<T>(IAsyncEnumerable<T>, ChannelOptions, Boolean, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannel<T>(System.Collections.Generic.IAsyncEnumerable<T>, System.Threading.Channels.ChannelOptions, System.Boolean, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannel
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 252
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannel<T>(this IAsyncEnumerable<T> source, ChannelOptions channelOptions, bool deferredExecution = false, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IAsyncEnumerable{{T}}
      description: The source data to use.
    - id: channelOptions
      type: System.Threading.Channels.ChannelOptions
      description: The options for configuring the new channel.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannel(Of T)(source As IAsyncEnumerable(Of T), channelOptions As ChannelOptions, deferredExecution As Boolean = False, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannel*
  nameWithType.vb: Extensions.ToChannel(Of T)(IAsyncEnumerable(Of T), ChannelOptions, Boolean, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannel(Of T)(System.Collections.Generic.IAsyncEnumerable(Of T), System.Threading.Channels.ChannelOptions, System.Boolean, System.Threading.CancellationToken)
  name.vb: ToChannel(Of T)(IAsyncEnumerable(Of T), ChannelOptions, Boolean, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  id: ToChannel``1(System.Collections.Generic.IAsyncEnumerable{``0},System.Int32,System.Boolean,System.Threading.CancellationToken,System.Boolean)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannel<T>(IAsyncEnumerable<T>, Int32, Boolean, CancellationToken, Boolean)
  nameWithType: Extensions.ToChannel<T>(IAsyncEnumerable<T>, Int32, Boolean, CancellationToken, Boolean)
  fullName: Open.ChannelExtensions.Extensions.ToChannel<T>(System.Collections.Generic.IAsyncEnumerable<T>, System.Int32, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannel
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 269
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannel<T>(this IAsyncEnumerable<T> source, int capacity, bool singleReader, CancellationToken cancellationToken, bool deferredExecution = false)
    parameters:
    - id: source
      type: System.Collections.Generic.IAsyncEnumerable{{T}}
      description: The source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    - id: deferredExecution
      type: System.Boolean
      description: If true, calls await Task.Yield() before writing to the channel.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannel(Of T)(source As IAsyncEnumerable(Of T), capacity As Integer, singleReader As Boolean, cancellationToken As CancellationToken, deferredExecution As Boolean = False) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannel*
  nameWithType.vb: Extensions.ToChannel(Of T)(IAsyncEnumerable(Of T), Int32, Boolean, CancellationToken, Boolean)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannel(Of T)(System.Collections.Generic.IAsyncEnumerable(Of T), System.Int32, System.Boolean, System.Threading.CancellationToken, System.Boolean)
  name.vb: ToChannel(Of T)(IAsyncEnumerable(Of T), Int32, Boolean, CancellationToken, Boolean)
- uid: Open.ChannelExtensions.Extensions.AsAsyncEnumerable``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.AsAsyncEnumerable``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken)
  id: AsAsyncEnumerable``1(System.Threading.Channels.ChannelReader{``0},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: AsAsyncEnumerable<T>(ChannelReader<T>, CancellationToken)
  nameWithType: Extensions.AsAsyncEnumerable<T>(ChannelReader<T>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.AsAsyncEnumerable<T>(System.Threading.Channels.ChannelReader<T>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: AsAsyncEnumerable
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 284
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nIterates over the results in a ChannelReader.\nProvided as an alternative to .ReadAllAsync() which at the time of publishing this, only exists in .NET Core 3.0 and not .NET Standard 2.1\n"
  example: []
  syntax:
    content: public static IAsyncEnumerable<T> AsAsyncEnumerable<T>(this ChannelReader<T> reader, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: reader
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token that will break out of the iteration.
    typeParameters:
    - id: T
      description: The output type of the channel.
    return:
      type: System.Collections.Generic.IAsyncEnumerable{{T}}
      description: An IAsyncEnumerable for iterating the channel.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function AsAsyncEnumerable(Of T)(reader As ChannelReader(Of T), cancellationToken As CancellationToken = Nothing) As IAsyncEnumerable(Of T)
  overload: Open.ChannelExtensions.Extensions.AsAsyncEnumerable*
  nameWithType.vb: Extensions.AsAsyncEnumerable(Of T)(ChannelReader(Of T), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.AsAsyncEnumerable(Of T)(System.Threading.Channels.ChannelReader(Of T), System.Threading.CancellationToken)
  name.vb: AsAsyncEnumerable(Of T)(ChannelReader(Of T), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.AsAsyncEnumerable``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.AsAsyncEnumerable``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken)
  id: AsAsyncEnumerable``2(System.Threading.Channels.Channel{``0,``1},System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: AsAsyncEnumerable<TIn, TOut>(Channel<TIn, TOut>, CancellationToken)
  nameWithType: Extensions.AsAsyncEnumerable<TIn, TOut>(Channel<TIn, TOut>, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.AsAsyncEnumerable<TIn, TOut>(System.Threading.Channels.Channel<TIn, TOut>, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: AsAsyncEnumerable
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 308
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nIterates over the results in a Channel.\nProvided as an alternative to .ReadAllAsync() which at the time of publishing this, only exists in .NET Core 3.0 and not .NET Standard 2.1\n"
  example: []
  syntax:
    content: public static IAsyncEnumerable<TOut> AsAsyncEnumerable<TIn, TOut>(this Channel<TIn, TOut> channel, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: channel
      type: System.Threading.Channels.Channel{{TIn},{TOut}}
      description: The reader to read from.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token that will break out of the iteration.
    typeParameters:
    - id: TIn
      description: The type recieved by the source channel.
    - id: TOut
      description: The outgoing type from the source channel.
    return:
      type: System.Collections.Generic.IAsyncEnumerable{{TOut}}
      description: An IAsyncEnumerable for iterating the channel.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function AsAsyncEnumerable(Of TIn, TOut)(channel As Channel(Of TIn, TOut), cancellationToken As CancellationToken = Nothing) As IAsyncEnumerable(Of TOut)
  overload: Open.ChannelExtensions.Extensions.AsAsyncEnumerable*
  nameWithType.vb: Extensions.AsAsyncEnumerable(Of TIn, TOut)(Channel(Of TIn, TOut), CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.AsAsyncEnumerable(Of TIn, TOut)(System.Threading.Channels.Channel(Of TIn, TOut), System.Threading.CancellationToken)
  name.vb: AsAsyncEnumerable(Of TIn, TOut)(Channel(Of TIn, TOut), CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  id: ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannelAsync<T>(IEnumerable<Func<T>>, ChannelOptions, Int32, CancellationToken)
  nameWithType: Extensions.ToChannelAsync<T>(IEnumerable<Func<T>>, ChannelOptions, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync<T>(System.Collections.Generic.IEnumerable<System.Func<T>>, System.Threading.Channels.ChannelOptions, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannelAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 334
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously executes all entries and writes their results to a channel.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannelAsync<T>(this IEnumerable<Func<T>> source, ChannelOptions channelOptions, int maxConcurrency = 1, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{T}}}
      description: The asynchronous source data to use.
    - id: channelOptions
      type: System.Threading.Channels.ChannelOptions
      description: The options for configuring the new channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannelAsync(Of T)(source As IEnumerable(Of Func(Of T)), channelOptions As ChannelOptions, maxConcurrency As Integer = 1, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannelAsync*
  nameWithType.vb: Extensions.ToChannelAsync(Of T)(IEnumerable(Of Func(Of T)), ChannelOptions, Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannelAsync(Of T)(System.Collections.Generic.IEnumerable(Of System.Func(Of T)), System.Threading.Channels.ChannelOptions, System.Int32, System.Threading.CancellationToken)
  name.vb: ToChannelAsync(Of T)(IEnumerable(Of Func(Of T)), ChannelOptions, Int32, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  id: ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Func{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannelAsync<T>(IEnumerable<Func<T>>, Int32, Boolean, Int32, CancellationToken)
  nameWithType: Extensions.ToChannelAsync<T>(IEnumerable<Func<T>>, Int32, Boolean, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync<T>(System.Collections.Generic.IEnumerable<System.Func<T>>, System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannelAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 350
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nAsynchronously executes all entries and writes their results to a channel.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannelAsync<T>(this IEnumerable<Func<T>> source, int capacity = -1, bool singleReader = false, int maxConcurrency = 1, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Func{{T}}}
      description: The asynchronous source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannelAsync(Of T)(source As IEnumerable(Of Func(Of T)), capacity As Integer = -1, singleReader As Boolean = False, maxConcurrency As Integer = 1, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannelAsync*
  nameWithType.vb: Extensions.ToChannelAsync(Of T)(IEnumerable(Of Func(Of T)), Int32, Boolean, Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannelAsync(Of T)(System.Collections.Generic.IEnumerable(Of System.Func(Of T)), System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  name.vb: ToChannelAsync(Of T)(IEnumerable(Of Func(Of T)), Int32, Boolean, Int32, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  id: ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannelAsync<T>(IEnumerable<ValueTask<T>>, ChannelOptions, Int32, CancellationToken)
  nameWithType: Extensions.ToChannelAsync<T>(IEnumerable<ValueTask<T>>, ChannelOptions, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync<T>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<T>>, System.Threading.Channels.ChannelOptions, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannelAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 365
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannelAsync<T>(this IEnumerable<ValueTask<T>> source, ChannelOptions channelOptions, int maxConcurrency = 1, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{T}}}
      description: The asynchronous source data to use.
    - id: channelOptions
      type: System.Threading.Channels.ChannelOptions
      description: The options for configuring the new channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannelAsync(Of T)(source As IEnumerable(Of ValueTask(Of T)), channelOptions As ChannelOptions, maxConcurrency As Integer = 1, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannelAsync*
  nameWithType.vb: Extensions.ToChannelAsync(Of T)(IEnumerable(Of ValueTask(Of T)), ChannelOptions, Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannelAsync(Of T)(System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of T)), System.Threading.Channels.ChannelOptions, System.Int32, System.Threading.CancellationToken)
  name.vb: ToChannelAsync(Of T)(IEnumerable(Of ValueTask(Of T)), ChannelOptions, Int32, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  id: ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannelAsync<T>(IEnumerable<ValueTask<T>>, Int32, Boolean, Int32, CancellationToken)
  nameWithType: Extensions.ToChannelAsync<T>(IEnumerable<ValueTask<T>>, Int32, Boolean, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync<T>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<T>>, System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannelAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 381
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannelAsync<T>(this IEnumerable<ValueTask<T>> source, int capacity = -1, bool singleReader = false, int maxConcurrency = 1, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{T}}}
      description: The asynchronous source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannelAsync(Of T)(source As IEnumerable(Of ValueTask(Of T)), capacity As Integer = -1, singleReader As Boolean = False, maxConcurrency As Integer = 1, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannelAsync*
  nameWithType.vb: Extensions.ToChannelAsync(Of T)(IEnumerable(Of ValueTask(Of T)), Int32, Boolean, Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannelAsync(Of T)(System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of T)), System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  name.vb: ToChannelAsync(Of T)(IEnumerable(Of ValueTask(Of T)), Int32, Boolean, Int32, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  id: ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Threading.Channels.ChannelOptions,System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannelAsync<T>(IEnumerable<Task<T>>, ChannelOptions, Int32, CancellationToken)
  nameWithType: Extensions.ToChannelAsync<T>(IEnumerable<Task<T>>, ChannelOptions, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync<T>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<T>>, System.Threading.Channels.ChannelOptions, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannelAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 396
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannelAsync<T>(this IEnumerable<Task<T>> source, ChannelOptions channelOptions, int maxConcurrency = 1, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{T}}}
      description: The asynchronous source data to use.
    - id: channelOptions
      type: System.Threading.Channels.ChannelOptions
      description: The options for configuring the new channel.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannelAsync(Of T)(source As IEnumerable(Of Task(Of T)), channelOptions As ChannelOptions, maxConcurrency As Integer = 1, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannelAsync*
  nameWithType.vb: Extensions.ToChannelAsync(Of T)(IEnumerable(Of Task(Of T)), ChannelOptions, Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannelAsync(Of T)(System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of T)), System.Threading.Channels.ChannelOptions, System.Int32, System.Threading.CancellationToken)
  name.vb: ToChannelAsync(Of T)(IEnumerable(Of Task(Of T)), ChannelOptions, Int32, CancellationToken)
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  commentId: M:Open.ChannelExtensions.Extensions.ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  id: ToChannelAsync``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},System.Int32,System.Boolean,System.Int32,System.Threading.CancellationToken)
  isExtensionMethod: true
  parent: Open.ChannelExtensions.Extensions
  langs:
  - csharp
  - vb
  name: ToChannelAsync<T>(IEnumerable<Task<T>>, Int32, Boolean, Int32, CancellationToken)
  nameWithType: Extensions.ToChannelAsync<T>(IEnumerable<Task<T>>, Int32, Boolean, Int32, CancellationToken)
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync<T>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<T>>, System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: Open.ChannelExtensions/Extensions._.cs
      branch: master
      repo: https://github.com/electricessence/Open.ChannelExtensions.git
    id: ToChannelAsync
    path: ../Open.ChannelExtensions/Extensions._.cs
    startLine: 412
  assemblies:
  - Open.ChannelExtensions
  namespace: Open.ChannelExtensions
  summary: "\nWrites all entries from the source to a channel and calls complete when finished.\n"
  example: []
  syntax:
    content: public static ChannelReader<T> ToChannelAsync<T>(this IEnumerable<Task<T>> source, int capacity = -1, bool singleReader = false, int maxConcurrency = 1, CancellationToken cancellationToken = default(CancellationToken))
    parameters:
    - id: source
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{T}}}
      description: The asynchronous source data to use.
    - id: capacity
      type: System.Int32
      description: The optional bounded capacity of the channel. Default is unbound.
    - id: singleReader
      type: System.Boolean
      description: True will cause the resultant reader to optimize for the assumption that no concurrent read operations will occur.
    - id: maxConcurrency
      type: System.Int32
      description: The maximum number of concurrent operations.  Greater than 1 may likely cause results to be out of order.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: An optional cancellation token.
    typeParameters:
    - id: T
      description: The input type of the channel.
    return:
      type: System.Threading.Channels.ChannelReader{{T}}
      description: The channel reader containing the results.
    content.vb: >-
      <ExtensionAttribute>

      Public Shared Function ToChannelAsync(Of T)(source As IEnumerable(Of Task(Of T)), capacity As Integer = -1, singleReader As Boolean = False, maxConcurrency As Integer = 1, cancellationToken As CancellationToken = Nothing) As ChannelReader(Of T)
  overload: Open.ChannelExtensions.Extensions.ToChannelAsync*
  nameWithType.vb: Extensions.ToChannelAsync(Of T)(IEnumerable(Of Task(Of T)), Int32, Boolean, Int32, CancellationToken)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: Open.ChannelExtensions.Extensions.ToChannelAsync(Of T)(System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of T)), System.Int32, System.Boolean, System.Int32, System.Threading.CancellationToken)
  name.vb: ToChannelAsync(Of T)(IEnumerable(Of Task(Of T)), Int32, Boolean, Int32, CancellationToken)
references:
- uid: Open.ChannelExtensions
  commentId: N:Open.ChannelExtensions
  name: Open.ChannelExtensions
  nameWithType: Open.ChannelExtensions
  fullName: Open.ChannelExtensions
- uid: System.Object
  commentId: T:System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Object.Equals(System.Object)
  commentId: M:System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  nameWithType: Object.Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  commentId: M:System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  nameWithType: Object.Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.GetHashCode
  commentId: M:System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  nameWithType: Object.GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.GetType
  commentId: M:System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  nameWithType: Object.GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.MemberwiseClone
  commentId: M:System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  nameWithType: Object.MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  nameWithType: Object.ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Object.ToString
  commentId: M:System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  nameWithType: Object.ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
- uid: System
  commentId: N:System
  isExternal: true
  name: System
  nameWithType: System
  fullName: System
- uid: Open.ChannelExtensions.Extensions.Batch*
  commentId: Overload:Open.ChannelExtensions.Extensions.Batch
  name: Batch
  nameWithType: Extensions.Batch
  fullName: Open.ChannelExtensions.Extensions.Batch
- uid: System.Threading.Channels.ChannelReader{{T}}
  commentId: T:System.Threading.Channels.ChannelReader{``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<T>
  nameWithType: ChannelReader<T>
  fullName: System.Threading.Channels.ChannelReader<T>
  nameWithType.vb: ChannelReader(Of T)
  fullName.vb: System.Threading.Channels.ChannelReader(Of T)
  name.vb: ChannelReader(Of T)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Int32
  commentId: T:System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  commentId: T:System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Channels.ChannelReader{System.Collections.Generic.List{{T}}}
  commentId: T:System.Threading.Channels.ChannelReader{System.Collections.Generic.List{``0}}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<List<T>>
  nameWithType: ChannelReader<List<T>>
  fullName: System.Threading.Channels.ChannelReader<System.Collections.Generic.List<T>>
  nameWithType.vb: ChannelReader(Of List(Of T))
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.Collections.Generic.List(Of T))
  name.vb: ChannelReader(Of List(Of T))
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader`1
  commentId: T:System.Threading.Channels.ChannelReader`1
  isExternal: true
  name: ChannelReader<T>
  nameWithType: ChannelReader<T>
  fullName: System.Threading.Channels.ChannelReader<T>
  nameWithType.vb: ChannelReader(Of T)
  fullName.vb: System.Threading.Channels.ChannelReader(Of T)
  name.vb: ChannelReader(Of T)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels
  commentId: N:System.Threading.Channels
  isExternal: true
  name: System.Threading.Channels
  nameWithType: System.Threading.Channels
  fullName: System.Threading.Channels
- uid: Open.ChannelExtensions.Extensions.Filter*
  commentId: Overload:Open.ChannelExtensions.Extensions.Filter
  name: Filter
  nameWithType: Extensions.Filter
  fullName: Open.ChannelExtensions.Extensions.Filter
- uid: System.Func{{T},System.Boolean}
  commentId: T:System.Func{``0,System.Boolean}
  parent: System
  definition: System.Func`2
  name: Func<T, Boolean>
  nameWithType: Func<T, Boolean>
  fullName: System.Func<T, System.Boolean>
  nameWithType.vb: Func(Of T, Boolean)
  fullName.vb: System.Func(Of T, System.Boolean)
  name.vb: Func(Of T, Boolean)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func`2
  commentId: T:System.Func`2
  isExternal: true
  name: Func<T, TResult>
  nameWithType: Func<T, TResult>
  fullName: System.Func<T, TResult>
  nameWithType.vb: Func(Of T, TResult)
  fullName.vb: System.Func(Of T, TResult)
  name.vb: Func(Of T, TResult)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.Join*
  commentId: Overload:Open.ChannelExtensions.Extensions.Join
  name: Join
  nameWithType: Extensions.Join
  fullName: Open.ChannelExtensions.Extensions.Join
- uid: System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{{T}}}
  commentId: T:System.Threading.Channels.ChannelReader{System.Collections.Generic.IEnumerable{``0}}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<IEnumerable<T>>
  nameWithType: ChannelReader<IEnumerable<T>>
  fullName: System.Threading.Channels.ChannelReader<System.Collections.Generic.IEnumerable<T>>
  nameWithType.vb: ChannelReader(Of IEnumerable(Of T))
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.Collections.Generic.IEnumerable(Of T))
  name.vb: ChannelReader(Of IEnumerable(Of T))
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{{T}}}
  commentId: T:System.Threading.Channels.ChannelReader{System.Collections.Generic.ICollection{``0}}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<ICollection<T>>
  nameWithType: ChannelReader<ICollection<T>>
  fullName: System.Threading.Channels.ChannelReader<System.Collections.Generic.ICollection<T>>
  nameWithType.vb: ChannelReader(Of ICollection(Of T))
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.Collections.Generic.ICollection(Of T))
  name.vb: ChannelReader(Of ICollection(Of T))
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.ICollection`1
    name: ICollection
    nameWithType: ICollection
    fullName: System.Collections.Generic.ICollection
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.ICollection`1
    name: ICollection
    nameWithType: ICollection
    fullName: System.Collections.Generic.ICollection
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{{T}}}
  commentId: T:System.Threading.Channels.ChannelReader{System.Collections.Generic.IList{``0}}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<IList<T>>
  nameWithType: ChannelReader<IList<T>>
  fullName: System.Threading.Channels.ChannelReader<System.Collections.Generic.IList<T>>
  nameWithType.vb: ChannelReader(Of IList(Of T))
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.Collections.Generic.IList(Of T))
  name.vb: ChannelReader(Of IList(Of T))
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: System.Collections.Generic.IList
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: System.Collections.Generic.IList
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{{T}[]}
  commentId: T:System.Threading.Channels.ChannelReader{``0[]}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<T[]>
  nameWithType: ChannelReader<T[]>
  fullName: System.Threading.Channels.ChannelReader<T[]>
  nameWithType.vb: ChannelReader(Of T())
  fullName.vb: System.Threading.Channels.ChannelReader(Of T())
  name.vb: ChannelReader(Of T())
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ()
    nameWithType: ()
    fullName: ()
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{System.Collections.Generic.IAsyncEnumerable{{T}}}
  commentId: T:System.Threading.Channels.ChannelReader{System.Collections.Generic.IAsyncEnumerable{``0}}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<IAsyncEnumerable<T>>
  nameWithType: ChannelReader<IAsyncEnumerable<T>>
  fullName: System.Threading.Channels.ChannelReader<System.Collections.Generic.IAsyncEnumerable<T>>
  nameWithType.vb: ChannelReader(Of IAsyncEnumerable(Of T))
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.Collections.Generic.IAsyncEnumerable(Of T))
  name.vb: ChannelReader(Of IAsyncEnumerable(Of T))
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.IAsyncEnumerable`1
    name: IAsyncEnumerable
    nameWithType: IAsyncEnumerable
    fullName: System.Collections.Generic.IAsyncEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.IAsyncEnumerable`1
    name: IAsyncEnumerable
    nameWithType: IAsyncEnumerable
    fullName: System.Collections.Generic.IAsyncEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.PipeTo*
  commentId: Overload:Open.ChannelExtensions.Extensions.PipeTo
  name: PipeTo
  nameWithType: Extensions.PipeTo
  fullName: Open.ChannelExtensions.Extensions.PipeTo
- uid: System.Threading.Channels.ChannelWriter{{T}}
  commentId: T:System.Threading.Channels.ChannelWriter{``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelWriter`1
  name: ChannelWriter<T>
  nameWithType: ChannelWriter<T>
  fullName: System.Threading.Channels.ChannelWriter<T>
  nameWithType.vb: ChannelWriter(Of T)
  fullName.vb: System.Threading.Channels.ChannelWriter(Of T)
  name.vb: ChannelWriter(Of T)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.CancellationToken
  commentId: T:System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Threading.Tasks.ValueTask{System.Int64}
  commentId: T:System.Threading.Tasks.ValueTask{System.Int64}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.ValueTask`1
  name: ValueTask<Int64>
  nameWithType: ValueTask<Int64>
  fullName: System.Threading.Tasks.ValueTask<System.Int64>
  nameWithType.vb: ValueTask(Of Int64)
  fullName.vb: System.Threading.Tasks.ValueTask(Of System.Int64)
  name.vb: ValueTask(Of Int64)
  spec.csharp:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelWriter`1
  commentId: T:System.Threading.Channels.ChannelWriter`1
  isExternal: true
  name: ChannelWriter<T>
  nameWithType: ChannelWriter<T>
  fullName: System.Threading.Channels.ChannelWriter<T>
  nameWithType.vb: ChannelWriter(Of T)
  fullName.vb: System.Threading.Channels.ChannelWriter(Of T)
  name.vb: ChannelWriter(Of T)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading
  commentId: N:System.Threading
  isExternal: true
  name: System.Threading
  nameWithType: System.Threading
  fullName: System.Threading
- uid: System.Threading.Tasks.ValueTask`1
  commentId: T:System.Threading.Tasks.ValueTask`1
  isExternal: true
  name: ValueTask<TResult>
  nameWithType: ValueTask<TResult>
  fullName: System.Threading.Tasks.ValueTask<TResult>
  nameWithType.vb: ValueTask(Of TResult)
  fullName.vb: System.Threading.Tasks.ValueTask(Of TResult)
  name.vb: ValueTask(Of TResult)
  spec.csharp:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Tasks
  commentId: N:System.Threading.Tasks
  isExternal: true
  name: System.Threading.Tasks
  nameWithType: System.Threading.Tasks
  fullName: System.Threading.Tasks
- uid: System.Threading.Channels.Channel{{T}}
  commentId: T:System.Threading.Channels.Channel{``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.Channel`1
  name: Channel<T>
  nameWithType: Channel<T>
  fullName: System.Threading.Channels.Channel<T>
  nameWithType.vb: Channel(Of T)
  fullName.vb: System.Threading.Channels.Channel(Of T)
  name.vb: Channel(Of T)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`1
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`1
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.Channel`1
  commentId: T:System.Threading.Channels.Channel`1
  isExternal: true
  name: Channel<T>
  nameWithType: Channel<T>
  fullName: System.Threading.Channels.Channel<T>
  nameWithType.vb: Channel(Of T)
  fullName.vb: System.Threading.Channels.Channel(Of T)
  name.vb: Channel(Of T)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`1
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`1
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.PipeAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.PipeAsync
  name: PipeAsync
  nameWithType: Extensions.PipeAsync
  fullName: Open.ChannelExtensions.Extensions.PipeAsync
- uid: System.Threading.Channels.ChannelReader{{TIn}}
  commentId: T:System.Threading.Channels.ChannelReader{``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<TIn>
  nameWithType: ChannelReader<TIn>
  fullName: System.Threading.Channels.ChannelReader<TIn>
  nameWithType.vb: ChannelReader(Of TIn)
  fullName.vb: System.Threading.Channels.ChannelReader(Of TIn)
  name.vb: ChannelReader(Of TIn)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TIn},System.Threading.Tasks.ValueTask{{TOut}}}
  commentId: T:System.Func{``0,System.Threading.Tasks.ValueTask{``1}}
  parent: System
  definition: System.Func`2
  name: Func<TIn, ValueTask<TOut>>
  nameWithType: Func<TIn, ValueTask<TOut>>
  fullName: System.Func<TIn, System.Threading.Tasks.ValueTask<TOut>>
  nameWithType.vb: Func(Of TIn, ValueTask(Of TOut))
  fullName.vb: System.Func(Of TIn, System.Threading.Tasks.ValueTask(Of TOut))
  name.vb: Func(Of TIn, ValueTask(Of TOut))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{{TOut}}
  commentId: T:System.Threading.Channels.ChannelReader{``1}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<TOut>
  nameWithType: ChannelReader<TOut>
  fullName: System.Threading.Channels.ChannelReader<TOut>
  nameWithType.vb: ChannelReader(Of TOut)
  fullName.vb: System.Threading.Channels.ChannelReader(Of TOut)
  name.vb: ChannelReader(Of TOut)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.Channel{{TWrite},{TRead}}
  commentId: T:System.Threading.Channels.Channel{``0,``1}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.Channel`2
  name: Channel<TWrite, TRead>
  nameWithType: Channel<TWrite, TRead>
  fullName: System.Threading.Channels.Channel<TWrite, TRead>
  nameWithType.vb: Channel(Of TWrite, TRead)
  fullName.vb: System.Threading.Channels.Channel(Of TWrite, TRead)
  name.vb: Channel(Of TWrite, TRead)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},System.Threading.Tasks.ValueTask{{TOut}}}
  commentId: T:System.Func{``1,System.Threading.Tasks.ValueTask{``2}}
  parent: System
  definition: System.Func`2
  name: Func<TRead, ValueTask<TOut>>
  nameWithType: Func<TRead, ValueTask<TOut>>
  fullName: System.Func<TRead, System.Threading.Tasks.ValueTask<TOut>>
  nameWithType.vb: Func(Of TRead, ValueTask(Of TOut))
  fullName.vb: System.Func(Of TRead, System.Threading.Tasks.ValueTask(Of TOut))
  name.vb: Func(Of TRead, ValueTask(Of TOut))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.Channel`2
  commentId: T:System.Threading.Channels.Channel`2
  isExternal: true
  name: Channel<TWrite, TRead>
  nameWithType: Channel<TWrite, TRead>
  fullName: System.Threading.Channels.Channel<TWrite, TRead>
  nameWithType.vb: Channel(Of TWrite, TRead)
  fullName.vb: System.Threading.Channels.Channel(Of TWrite, TRead)
  name.vb: Channel(Of TWrite, TRead)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.TaskPipeAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.TaskPipeAsync
  name: TaskPipeAsync
  nameWithType: Extensions.TaskPipeAsync
  fullName: Open.ChannelExtensions.Extensions.TaskPipeAsync
- uid: System.Func{{TIn},System.Threading.Tasks.Task{{TOut}}}
  commentId: T:System.Func{``0,System.Threading.Tasks.Task{``1}}
  parent: System
  definition: System.Func`2
  name: Func<TIn, Task<TOut>>
  nameWithType: Func<TIn, Task<TOut>>
  fullName: System.Func<TIn, System.Threading.Tasks.Task<TOut>>
  nameWithType.vb: Func(Of TIn, Task(Of TOut))
  fullName.vb: System.Func(Of TIn, System.Threading.Tasks.Task(Of TOut))
  name.vb: Func(Of TIn, Task(Of TOut))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},System.Threading.Tasks.Task{{TOut}}}
  commentId: T:System.Func{``1,System.Threading.Tasks.Task{``2}}
  parent: System
  definition: System.Func`2
  name: Func<TRead, Task<TOut>>
  nameWithType: Func<TRead, Task<TOut>>
  fullName: System.Func<TRead, System.Threading.Tasks.Task<TOut>>
  nameWithType.vb: Func(Of TRead, Task(Of TOut))
  fullName.vb: System.Func(Of TRead, System.Threading.Tasks.Task(Of TOut))
  name.vb: Func(Of TRead, Task(Of TOut))
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.Pipe*
  commentId: Overload:Open.ChannelExtensions.Extensions.Pipe
  name: Pipe
  nameWithType: Extensions.Pipe
  fullName: Open.ChannelExtensions.Extensions.Pipe
- uid: System.Func{{TIn},{TOut}}
  commentId: T:System.Func{``0,``1}
  parent: System
  definition: System.Func`2
  name: Func<TIn, TOut>
  nameWithType: Func<TIn, TOut>
  fullName: System.Func<TIn, TOut>
  nameWithType.vb: Func(Of TIn, TOut)
  fullName.vb: System.Func(Of TIn, TOut)
  name.vb: Func(Of TIn, TOut)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},{TOut}}
  commentId: T:System.Func{``1,``2}
  parent: System
  definition: System.Func`2
  name: Func<TRead, TOut>
  nameWithType: Func<TRead, TOut>
  fullName: System.Func<TRead, TOut>
  nameWithType.vb: Func(Of TRead, TOut)
  fullName.vb: System.Func(Of TRead, TOut)
  name.vb: Func(Of TRead, TOut)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ReadAvailable*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAvailable
  name: ReadAvailable
  nameWithType: Extensions.ReadAvailable
  fullName: Open.ChannelExtensions.Extensions.ReadAvailable
- uid: System.Collections.Generic.IEnumerable{{T}}
  commentId: T:System.Collections.Generic.IEnumerable{``0}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<T>
  nameWithType: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  nameWithType.vb: IEnumerable(Of T)
  fullName.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable`1
  commentId: T:System.Collections.Generic.IEnumerable`1
  isExternal: true
  name: IEnumerable<T>
  nameWithType: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  nameWithType.vb: IEnumerable(Of T)
  fullName.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic
  commentId: N:System.Collections.Generic
  isExternal: true
  name: System.Collections.Generic
  nameWithType: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: Open.ChannelExtensions.Extensions.ReadBatchAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadBatchAsync
  name: ReadBatchAsync
  nameWithType: Extensions.ReadBatchAsync
  fullName: Open.ChannelExtensions.Extensions.ReadBatchAsync
- uid: System.Threading.Tasks.ValueTask{System.Collections.Generic.List{{T}}}
  commentId: T:System.Threading.Tasks.ValueTask{System.Collections.Generic.List{``0}}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.ValueTask`1
  name: ValueTask<List<T>>
  nameWithType: ValueTask<List<T>>
  fullName: System.Threading.Tasks.ValueTask<System.Collections.Generic.List<T>>
  nameWithType.vb: ValueTask(Of List(Of T))
  fullName.vb: System.Threading.Tasks.ValueTask(Of System.Collections.Generic.List(Of T))
  name.vb: ValueTask(Of List(Of T))
  spec.csharp:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Collections.Generic.List`1
    name: List
    nameWithType: List
    fullName: System.Collections.Generic.List
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync
  name: ReadUntilCancelledAsync
  nameWithType: Extensions.ReadUntilCancelledAsync
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelledAsync
- uid: System.Func{{T},System.Int64,System.Threading.Tasks.ValueTask}
  commentId: T:System.Func{``0,System.Int64,System.Threading.Tasks.ValueTask}
  parent: System
  definition: System.Func`3
  name: Func<T, Int64, ValueTask>
  nameWithType: Func<T, Int64, ValueTask>
  fullName: System.Func<T, System.Int64, System.Threading.Tasks.ValueTask>
  nameWithType.vb: Func(Of T, Int64, ValueTask)
  fullName.vb: System.Func(Of T, System.Int64, System.Threading.Tasks.ValueTask)
  name.vb: Func(Of T, Int64, ValueTask)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func`3
  commentId: T:System.Func`3
  isExternal: true
  name: Func<T1, T2, TResult>
  nameWithType: Func<T1, T2, TResult>
  fullName: System.Func<T1, T2, TResult>
  nameWithType.vb: Func(Of T1, T2, TResult)
  fullName.vb: System.Func(Of T1, T2, TResult)
  name.vb: Func(Of T1, T2, TResult)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},System.Int64,System.Threading.Tasks.ValueTask}
  commentId: T:System.Func{``1,System.Int64,System.Threading.Tasks.ValueTask}
  parent: System
  definition: System.Func`3
  name: Func<TRead, Int64, ValueTask>
  nameWithType: Func<TRead, Int64, ValueTask>
  fullName: System.Func<TRead, System.Int64, System.Threading.Tasks.ValueTask>
  nameWithType.vb: Func(Of TRead, Int64, ValueTask)
  fullName.vb: System.Func(Of TRead, System.Int64, System.Threading.Tasks.ValueTask)
  name.vb: Func(Of TRead, Int64, ValueTask)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{T},System.Threading.Tasks.ValueTask}
  commentId: T:System.Func{``0,System.Threading.Tasks.ValueTask}
  parent: System
  definition: System.Func`2
  name: Func<T, ValueTask>
  nameWithType: Func<T, ValueTask>
  fullName: System.Func<T, System.Threading.Tasks.ValueTask>
  nameWithType.vb: Func(Of T, ValueTask)
  fullName.vb: System.Func(Of T, System.Threading.Tasks.ValueTask)
  name.vb: Func(Of T, ValueTask)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},System.Threading.Tasks.ValueTask}
  commentId: T:System.Func{``1,System.Threading.Tasks.ValueTask}
  parent: System
  definition: System.Func`2
  name: Func<TRead, ValueTask>
  nameWithType: Func<TRead, ValueTask>
  fullName: System.Func<TRead, System.Threading.Tasks.ValueTask>
  nameWithType.vb: Func(Of TRead, ValueTask)
  fullName.vb: System.Func(Of TRead, System.Threading.Tasks.ValueTask)
  name.vb: Func(Of TRead, ValueTask)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.ValueTask
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ReadUntilCancelled*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadUntilCancelled
  name: ReadUntilCancelled
  nameWithType: Extensions.ReadUntilCancelled
  fullName: Open.ChannelExtensions.Extensions.ReadUntilCancelled
- uid: System.Action{{T},System.Int64}
  commentId: T:System.Action{``0,System.Int64}
  parent: System
  definition: System.Action`2
  name: Action<T, Int64>
  nameWithType: Action<T, Int64>
  fullName: System.Action<T, System.Int64>
  nameWithType.vb: Action(Of T, Int64)
  fullName.vb: System.Action(Of T, System.Int64)
  name.vb: Action(Of T, Int64)
  spec.csharp:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Action`2
  commentId: T:System.Action`2
  isExternal: true
  name: Action<T1, T2>
  nameWithType: Action<T1, T2>
  fullName: System.Action<T1, T2>
  nameWithType.vb: Action(Of T1, T2)
  fullName.vb: System.Action(Of T1, T2)
  name.vb: Action(Of T1, T2)
  spec.csharp:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T1
    nameWithType: T1
    fullName: T1
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T2
    nameWithType: T2
    fullName: T2
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Action{{TRead},System.Int64}
  commentId: T:System.Action{``1,System.Int64}
  parent: System
  definition: System.Action`2
  name: Action<TRead, Int64>
  nameWithType: Action<TRead, Int64>
  fullName: System.Action<TRead, System.Int64>
  nameWithType.vb: Action(Of TRead, Int64)
  fullName.vb: System.Action(Of TRead, System.Int64)
  name.vb: Action(Of TRead, Int64)
  spec.csharp:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`2
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Action{{T}}
  commentId: T:System.Action{``0}
  parent: System
  definition: System.Action`1
  name: Action<T>
  nameWithType: Action<T>
  fullName: System.Action<T>
  nameWithType.vb: Action(Of T)
  fullName.vb: System.Action(Of T)
  name.vb: Action(Of T)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Action`1
  commentId: T:System.Action`1
  isExternal: true
  name: Action<T>
  nameWithType: Action<T>
  fullName: System.Action<T>
  nameWithType.vb: Action(Of T)
  fullName.vb: System.Action(Of T)
  name.vb: Action(Of T)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Action{{TRead}}
  commentId: T:System.Action{``1}
  parent: System
  definition: System.Action`1
  name: Action<TRead>
  nameWithType: Action<TRead>
  fullName: System.Action<TRead>
  nameWithType.vb: Action(Of TRead)
  fullName.vb: System.Action(Of TRead)
  name.vb: Action(Of TRead)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ReadAllAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAllAsync
  name: ReadAllAsync
  nameWithType: Extensions.ReadAllAsync
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsync
- uid: Open.ChannelExtensions.Extensions.TaskReadAllAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.TaskReadAllAsync
  name: TaskReadAllAsync
  nameWithType: Extensions.TaskReadAllAsync
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllAsync
- uid: System.Func{{TRead},System.Int64,System.Threading.Tasks.Task}
  commentId: T:System.Func{``1,System.Int64,System.Threading.Tasks.Task}
  parent: System
  definition: System.Func`3
  name: Func<TRead, Int64, Task>
  nameWithType: Func<TRead, Int64, Task>
  fullName: System.Func<TRead, System.Int64, System.Threading.Tasks.Task>
  nameWithType.vb: Func(Of TRead, Int64, Task)
  fullName.vb: System.Func(Of TRead, System.Int64, System.Threading.Tasks.Task)
  name.vb: Func(Of TRead, Int64, Task)
  spec.csharp:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`3
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{T},System.Threading.Tasks.Task}
  commentId: T:System.Func{``0,System.Threading.Tasks.Task}
  parent: System
  definition: System.Func`2
  name: Func<T, Task>
  nameWithType: Func<T, Task>
  fullName: System.Func<T, System.Threading.Tasks.Task>
  nameWithType.vb: Func(Of T, Task)
  fullName.vb: System.Func(Of T, System.Threading.Tasks.Task)
  name.vb: Func(Of T, Task)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},System.Threading.Tasks.Task}
  commentId: T:System.Func{``1,System.Threading.Tasks.Task}
  parent: System
  definition: System.Func`2
  name: Func<TRead, Task>
  nameWithType: Func<TRead, Task>
  fullName: System.Func<TRead, System.Threading.Tasks.Task>
  nameWithType.vb: Func(Of TRead, Task)
  fullName.vb: System.Func(Of TRead, System.Threading.Tasks.Task)
  name.vb: Func(Of TRead, Task)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ReadAll*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAll
  name: ReadAll
  nameWithType: Extensions.ReadAll
  fullName: Open.ChannelExtensions.Extensions.ReadAll
- uid: Open.ChannelExtensions.Extensions.ReadAllAsLines*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAllAsLines
  name: ReadAllAsLines
  nameWithType: Extensions.ReadAllAsLines
  fullName: Open.ChannelExtensions.Extensions.ReadAllAsLines
- uid: System.Threading.Channels.ChannelReader{System.String}
  commentId: T:System.Threading.Channels.ChannelReader{System.String}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<String>
  nameWithType: ChannelReader<String>
  fullName: System.Threading.Channels.ChannelReader<System.String>
  nameWithType.vb: ChannelReader(Of String)
  fullName.vb: System.Threading.Channels.ChannelReader(Of System.String)
  name.vb: ChannelReader(Of String)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.IO.TextWriter
  commentId: T:System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.IO
  commentId: N:System.IO
  isExternal: true
  name: System.IO
  nameWithType: System.IO
  fullName: System.IO
- uid: System.Threading.Channels.Channel{{T},System.String}
  commentId: T:System.Threading.Channels.Channel{``0,System.String}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.Channel`2
  name: Channel<T, String>
  nameWithType: Channel<T, String>
  fullName: System.Threading.Channels.Channel<T, System.String>
  nameWithType.vb: Channel(Of T, String)
  fullName.vb: System.Threading.Channels.Channel(Of T, System.String)
  name.vb: Channel(Of T, String)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ToListAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ToListAsync
  name: ToListAsync
  nameWithType: Extensions.ToListAsync
  fullName: Open.ChannelExtensions.Extensions.ToListAsync
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync
  name: ReadAllConcurrentlyAsync
  nameWithType: Extensions.ReadAllConcurrentlyAsync
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrentlyAsync
- uid: System.Threading.Tasks.Task{System.Int64}
  commentId: T:System.Threading.Tasks.Task{System.Int64}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<Int64>
  nameWithType: Task<Int64>
  fullName: System.Threading.Tasks.Task<System.Int64>
  nameWithType.vb: Task(Of Int64)
  fullName.vb: System.Threading.Tasks.Task(Of System.Int64)
  name.vb: Task(Of Int64)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: System.Int64
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Tasks.Task`1
  commentId: T:System.Threading.Tasks.Task`1
  isExternal: true
  name: Task<TResult>
  nameWithType: Task<TResult>
  fullName: System.Threading.Tasks.Task<TResult>
  nameWithType.vb: Task(Of TResult)
  fullName.vb: System.Threading.Tasks.Task(Of TResult)
  name.vb: Task(Of TResult)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync
  name: TaskReadAllConcurrentlyAsync
  nameWithType: Extensions.TaskReadAllConcurrentlyAsync
  fullName: Open.ChannelExtensions.Extensions.TaskReadAllConcurrentlyAsync
- uid: Open.ChannelExtensions.Extensions.ReadAllConcurrently*
  commentId: Overload:Open.ChannelExtensions.Extensions.ReadAllConcurrently
  name: ReadAllConcurrently
  nameWithType: Extensions.ReadAllConcurrently
  fullName: Open.ChannelExtensions.Extensions.ReadAllConcurrently
- uid: Open.ChannelExtensions.Extensions.SourceAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.SourceAsync
  name: SourceAsync
  nameWithType: Extensions.SourceAsync
  fullName: Open.ChannelExtensions.Extensions.SourceAsync
- uid: System.Collections.Generic.IEnumerable{System.Func{{TWrite}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Func{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Func<TWrite>>
  nameWithType: IEnumerable<Func<TWrite>>
  fullName: System.Collections.Generic.IEnumerable<System.Func<TWrite>>
  nameWithType.vb: IEnumerable(Of Func(Of TWrite))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Func(Of TWrite))
  name.vb: IEnumerable(Of Func(Of TWrite))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{{TRead}}
  commentId: T:System.Threading.Channels.ChannelReader{``1}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<TRead>
  nameWithType: ChannelReader<TRead>
  fullName: System.Threading.Channels.ChannelReader<TRead>
  nameWithType.vb: ChannelReader(Of TRead)
  fullName.vb: System.Threading.Channels.ChannelReader(Of TRead)
  name.vb: ChannelReader(Of TRead)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{TWrite}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<ValueTask<TWrite>>
  nameWithType: IEnumerable<ValueTask<TWrite>>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<TWrite>>
  nameWithType.vb: IEnumerable(Of ValueTask(Of TWrite))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of TWrite))
  name.vb: IEnumerable(Of ValueTask(Of TWrite))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{TWrite}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Task<TWrite>>
  nameWithType: IEnumerable<Task<TWrite>>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TWrite>>
  nameWithType.vb: IEnumerable(Of Task(Of TWrite))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of TWrite))
  name.vb: IEnumerable(Of Task(Of TWrite))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.Source*
  commentId: Overload:Open.ChannelExtensions.Extensions.Source
  name: Source
  nameWithType: Extensions.Source
  fullName: Open.ChannelExtensions.Extensions.Source
- uid: System.Collections.Generic.IEnumerable{{TWrite}}
  commentId: T:System.Collections.Generic.IEnumerable{``0}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<TWrite>
  nameWithType: IEnumerable<TWrite>
  fullName: System.Collections.Generic.IEnumerable<TWrite>
  nameWithType.vb: IEnumerable(Of TWrite)
  fullName.vb: System.Collections.Generic.IEnumerable(Of TWrite)
  name.vb: IEnumerable(Of TWrite)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.Channel{System.String,{T}}
  commentId: T:System.Threading.Channels.Channel{System.String,``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.Channel`2
  name: Channel<String, T>
  nameWithType: Channel<String, T>
  fullName: System.Threading.Channels.Channel<System.String, T>
  nameWithType.vb: Channel(Of String, T)
  fullName.vb: System.Threading.Channels.Channel(Of System.String, T)
  name.vb: Channel(Of String, T)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: System.IO.TextReader
  commentId: T:System.IO.TextReader
  parent: System.IO
  isExternal: true
  name: TextReader
  nameWithType: TextReader
  fullName: System.IO.TextReader
- uid: System.Collections.Generic.IAsyncEnumerable{{TWrite}}
  commentId: T:System.Collections.Generic.IAsyncEnumerable{``0}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IAsyncEnumerable`1
  name: IAsyncEnumerable<TWrite>
  nameWithType: IAsyncEnumerable<TWrite>
  fullName: System.Collections.Generic.IAsyncEnumerable<TWrite>
  nameWithType.vb: IAsyncEnumerable(Of TWrite)
  fullName.vb: System.Collections.Generic.IAsyncEnumerable(Of TWrite)
  name.vb: IAsyncEnumerable(Of TWrite)
  spec.csharp:
  - uid: System.Collections.Generic.IAsyncEnumerable`1
    name: IAsyncEnumerable
    nameWithType: IAsyncEnumerable
    fullName: System.Collections.Generic.IAsyncEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IAsyncEnumerable`1
    name: IAsyncEnumerable
    nameWithType: IAsyncEnumerable
    fullName: System.Collections.Generic.IAsyncEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IAsyncEnumerable`1
  commentId: T:System.Collections.Generic.IAsyncEnumerable`1
  isExternal: true
  name: IAsyncEnumerable<T>
  nameWithType: IAsyncEnumerable<T>
  fullName: System.Collections.Generic.IAsyncEnumerable<T>
  nameWithType.vb: IAsyncEnumerable(Of T)
  fullName.vb: System.Collections.Generic.IAsyncEnumerable(Of T)
  name.vb: IAsyncEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IAsyncEnumerable`1
    name: IAsyncEnumerable
    nameWithType: IAsyncEnumerable
    fullName: System.Collections.Generic.IAsyncEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IAsyncEnumerable`1
    name: IAsyncEnumerable
    nameWithType: IAsyncEnumerable
    fullName: System.Collections.Generic.IAsyncEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.Transform*
  commentId: Overload:Open.ChannelExtensions.Extensions.Transform
  name: Transform
  nameWithType: Extensions.Transform
  fullName: Open.ChannelExtensions.Extensions.Transform
- uid: System.Func{{T},{TResult}}
  commentId: T:System.Func{``0,``1}
  parent: System
  definition: System.Func`2
  name: Func<T, TResult>
  nameWithType: Func<T, TResult>
  fullName: System.Func<T, TResult>
  nameWithType.vb: Func(Of T, TResult)
  fullName.vb: System.Func(Of T, TResult)
  name.vb: Func(Of T, TResult)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Threading.Channels.ChannelReader{{TResult}}
  commentId: T:System.Threading.Channels.ChannelReader{``1}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<TResult>
  nameWithType: ChannelReader<TResult>
  fullName: System.Threading.Channels.ChannelReader<TResult>
  nameWithType.vb: ChannelReader(Of TResult)
  fullName.vb: System.Threading.Channels.ChannelReader(Of TResult)
  name.vb: ChannelReader(Of TResult)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Func{{TRead},{TResult}}
  commentId: T:System.Func{``1,``2}
  parent: System
  definition: System.Func`2
  name: Func<TRead, TResult>
  nameWithType: Func<TRead, TResult>
  fullName: System.Func<TRead, TResult>
  nameWithType.vb: Func(Of TRead, TResult)
  fullName.vb: System.Func(Of TRead, TResult)
  name.vb: Func(Of TRead, TResult)
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.TransformChannel{{TWrite},{TRead},{TResult}}
  commentId: T:Open.ChannelExtensions.TransformChannel{``0,``1,``2}
  parent: Open.ChannelExtensions
  definition: Open.ChannelExtensions.TransformChannel`3
  name: TransformChannel<TWrite, TRead, TResult>
  nameWithType: TransformChannel<TWrite, TRead, TResult>
  fullName: Open.ChannelExtensions.TransformChannel<TWrite, TRead, TResult>
  nameWithType.vb: TransformChannel(Of TWrite, TRead, TResult)
  fullName.vb: Open.ChannelExtensions.TransformChannel(Of TWrite, TRead, TResult)
  name.vb: TransformChannel(Of TWrite, TRead, TResult)
  spec.csharp:
  - uid: Open.ChannelExtensions.TransformChannel`3
    name: TransformChannel
    nameWithType: TransformChannel
    fullName: Open.ChannelExtensions.TransformChannel
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: Open.ChannelExtensions.TransformChannel`3
    name: TransformChannel
    nameWithType: TransformChannel
    fullName: Open.ChannelExtensions.TransformChannel
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.TransformChannel`3
  commentId: T:Open.ChannelExtensions.TransformChannel`3
  name: TransformChannel<TWrite, TRead, TResult>
  nameWithType: TransformChannel<TWrite, TRead, TResult>
  fullName: Open.ChannelExtensions.TransformChannel<TWrite, TRead, TResult>
  nameWithType.vb: TransformChannel(Of TWrite, TRead, TResult)
  fullName.vb: Open.ChannelExtensions.TransformChannel(Of TWrite, TRead, TResult)
  name.vb: TransformChannel(Of TWrite, TRead, TResult)
  spec.csharp:
  - uid: Open.ChannelExtensions.TransformChannel`3
    name: TransformChannel
    nameWithType: TransformChannel
    fullName: Open.ChannelExtensions.TransformChannel
  - name: <
    nameWithType: <
    fullName: <
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: Open.ChannelExtensions.TransformChannel`3
    name: TransformChannel
    nameWithType: TransformChannel
    fullName: Open.ChannelExtensions.TransformChannel
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TWrite
    nameWithType: TWrite
    fullName: TWrite
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TRead
    nameWithType: TRead
    fullName: TRead
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.TransformChannel{{T},{TResult}}
  commentId: T:Open.ChannelExtensions.TransformChannel{``0,``1}
  parent: Open.ChannelExtensions
  definition: Open.ChannelExtensions.TransformChannel`2
  name: TransformChannel<T, TResult>
  nameWithType: TransformChannel<T, TResult>
  fullName: Open.ChannelExtensions.TransformChannel<T, TResult>
  nameWithType.vb: TransformChannel(Of T, TResult)
  fullName.vb: Open.ChannelExtensions.TransformChannel(Of T, TResult)
  name.vb: TransformChannel(Of T, TResult)
  spec.csharp:
  - uid: Open.ChannelExtensions.TransformChannel`2
    name: TransformChannel
    nameWithType: TransformChannel
    fullName: Open.ChannelExtensions.TransformChannel
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: Open.ChannelExtensions.TransformChannel`2
    name: TransformChannel
    nameWithType: TransformChannel
    fullName: Open.ChannelExtensions.TransformChannel
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.TransformChannel`2
  commentId: T:Open.ChannelExtensions.TransformChannel`2
  name: TransformChannel<T, TResult>
  nameWithType: TransformChannel<T, TResult>
  fullName: Open.ChannelExtensions.TransformChannel<T, TResult>
  nameWithType.vb: TransformChannel(Of T, TResult)
  fullName.vb: Open.ChannelExtensions.TransformChannel(Of T, TResult)
  name.vb: TransformChannel(Of T, TResult)
  spec.csharp:
  - uid: Open.ChannelExtensions.TransformChannel`2
    name: TransformChannel
    nameWithType: TransformChannel
    fullName: Open.ChannelExtensions.TransformChannel
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: Open.ChannelExtensions.TransformChannel`2
    name: TransformChannel
    nameWithType: TransformChannel
    fullName: Open.ChannelExtensions.TransformChannel
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.OfType*
  commentId: Overload:Open.ChannelExtensions.Extensions.OfType
  name: OfType
  nameWithType: Extensions.OfType
  fullName: Open.ChannelExtensions.Extensions.OfType
- uid: System.Threading.Channels.ChannelReader{{TSource}}
  commentId: T:System.Threading.Channels.ChannelReader{``0}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelReader`1
  name: ChannelReader<TSource>
  nameWithType: ChannelReader<TSource>
  fullName: System.Threading.Channels.ChannelReader<TSource>
  nameWithType.vb: ChannelReader(Of TSource)
  fullName.vb: System.Threading.Channels.ChannelReader(Of TSource)
  name.vb: ChannelReader(Of TSource)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TSource
    nameWithType: TSource
    fullName: TSource
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelReader`1
    name: ChannelReader
    nameWithType: ChannelReader
    fullName: System.Threading.Channels.ChannelReader
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TSource
    nameWithType: TSource
    fullName: TSource
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.WriteAllAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.WriteAllAsync
  name: WriteAllAsync
  nameWithType: Extensions.WriteAllAsync
  fullName: Open.ChannelExtensions.Extensions.WriteAllAsync
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{{T}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Threading.Tasks.ValueTask{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<ValueTask<T>>
  nameWithType: IEnumerable<ValueTask<T>>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.ValueTask<T>>
  nameWithType.vb: IEnumerable(Of ValueTask(Of T))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.ValueTask(Of T))
  name.vb: IEnumerable(Of ValueTask(Of T))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.ValueTask`1
    name: ValueTask
    nameWithType: ValueTask
    fullName: System.Threading.Tasks.ValueTask
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{{T}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Task<T>>
  nameWithType: IEnumerable<Task<T>>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<T>>
  nameWithType.vb: IEnumerable(Of Task(Of T))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task(Of T))
  name.vb: IEnumerable(Of Task(Of T))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Func{{T}}}
  commentId: T:System.Collections.Generic.IEnumerable{System.Func{``0}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Func<T>>
  nameWithType: IEnumerable<Func<T>>
  fullName: System.Collections.Generic.IEnumerable<System.Func<T>>
  nameWithType.vb: IEnumerable(Of Func(Of T))
  fullName.vb: System.Collections.Generic.IEnumerable(Of System.Func(Of T))
  name.vb: IEnumerable(Of Func(Of T))
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: System.Func
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.WriteAll*
  commentId: Overload:Open.ChannelExtensions.Extensions.WriteAll
  name: WriteAll
  nameWithType: Extensions.WriteAll
  fullName: Open.ChannelExtensions.Extensions.WriteAll
- uid: Open.ChannelExtensions.Extensions.WriteAllLines*
  commentId: Overload:Open.ChannelExtensions.Extensions.WriteAllLines
  name: WriteAllLines
  nameWithType: Extensions.WriteAllLines
  fullName: Open.ChannelExtensions.Extensions.WriteAllLines
- uid: System.Threading.Channels.ChannelWriter{System.String}
  commentId: T:System.Threading.Channels.ChannelWriter{System.String}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.ChannelWriter`1
  name: ChannelWriter<String>
  nameWithType: ChannelWriter<String>
  fullName: System.Threading.Channels.ChannelWriter<System.String>
  nameWithType.vb: ChannelWriter(Of String)
  fullName.vb: System.Threading.Channels.ChannelWriter(Of System.String)
  name.vb: ChannelWriter(Of String)
  spec.csharp:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.ChannelWriter`1
    name: ChannelWriter
    nameWithType: ChannelWriter
    fullName: System.Threading.Channels.ChannelWriter
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - uid: System.String
    name: String
    nameWithType: String
    fullName: System.String
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IAsyncEnumerable{{T}}
  commentId: T:System.Collections.Generic.IAsyncEnumerable{``0}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IAsyncEnumerable`1
  name: IAsyncEnumerable<T>
  nameWithType: IAsyncEnumerable<T>
  fullName: System.Collections.Generic.IAsyncEnumerable<T>
  nameWithType.vb: IAsyncEnumerable(Of T)
  fullName.vb: System.Collections.Generic.IAsyncEnumerable(Of T)
  name.vb: IAsyncEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IAsyncEnumerable`1
    name: IAsyncEnumerable
    nameWithType: IAsyncEnumerable
    fullName: System.Collections.Generic.IAsyncEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: T
    nameWithType: T
    fullName: T
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IAsyncEnumerable`1
    name: IAsyncEnumerable
    nameWithType: IAsyncEnumerable
    fullName: System.Collections.Generic.IAsyncEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: T
    nameWithType: T
    fullName: T
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync
  name: WriteAllConcurrentlyAsync
  nameWithType: Extensions.WriteAllConcurrentlyAsync
  fullName: Open.ChannelExtensions.Extensions.WriteAllConcurrentlyAsync
- uid: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync
  name: WaitToWriteAndThrowIfClosedAsync
  nameWithType: Extensions.WaitToWriteAndThrowIfClosedAsync
  fullName: Open.ChannelExtensions.Extensions.WaitToWriteAndThrowIfClosedAsync
- uid: System.String
  commentId: T:System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Tasks.ValueTask
  commentId: T:System.Threading.Tasks.ValueTask
  parent: System.Threading.Tasks
  isExternal: true
  name: ValueTask
  nameWithType: ValueTask
  fullName: System.Threading.Tasks.ValueTask
- uid: Open.ChannelExtensions.Extensions.CompleteAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.CompleteAsync
  name: CompleteAsync
  nameWithType: Extensions.CompleteAsync
  fullName: Open.ChannelExtensions.Extensions.CompleteAsync
- uid: System.Exception
  commentId: T:System.Exception
  parent: System
  isExternal: true
  name: Exception
  nameWithType: Exception
  fullName: System.Exception
- uid: System.Threading.Tasks.Task
  commentId: T:System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: Open.ChannelExtensions.Extensions.ToChannel*
  commentId: Overload:Open.ChannelExtensions.Extensions.ToChannel
  name: ToChannel
  nameWithType: Extensions.ToChannel
  fullName: Open.ChannelExtensions.Extensions.ToChannel
- uid: System.Threading.Channels.ChannelOptions
  commentId: T:System.Threading.Channels.ChannelOptions
  parent: System.Threading.Channels
  isExternal: true
  name: ChannelOptions
  nameWithType: ChannelOptions
  fullName: System.Threading.Channels.ChannelOptions
- uid: Open.ChannelExtensions.Extensions.AsAsyncEnumerable*
  commentId: Overload:Open.ChannelExtensions.Extensions.AsAsyncEnumerable
  name: AsAsyncEnumerable
  nameWithType: Extensions.AsAsyncEnumerable
  fullName: Open.ChannelExtensions.Extensions.AsAsyncEnumerable
- uid: System.Threading.Channels.Channel{{TIn},{TOut}}
  commentId: T:System.Threading.Channels.Channel{``0,``1}
  parent: System.Threading.Channels
  definition: System.Threading.Channels.Channel`2
  name: Channel<TIn, TOut>
  nameWithType: Channel<TIn, TOut>
  fullName: System.Threading.Channels.Channel<TIn, TOut>
  nameWithType.vb: Channel(Of TIn, TOut)
  fullName.vb: System.Threading.Channels.Channel(Of TIn, TOut)
  name.vb: Channel(Of TIn, TOut)
  spec.csharp:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Channels.Channel`2
    name: Channel
    nameWithType: Channel
    fullName: System.Threading.Channels.Channel
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TIn
    nameWithType: TIn
    fullName: TIn
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: System.Collections.Generic.IAsyncEnumerable{{TOut}}
  commentId: T:System.Collections.Generic.IAsyncEnumerable{``1}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IAsyncEnumerable`1
  name: IAsyncEnumerable<TOut>
  nameWithType: IAsyncEnumerable<TOut>
  fullName: System.Collections.Generic.IAsyncEnumerable<TOut>
  nameWithType.vb: IAsyncEnumerable(Of TOut)
  fullName.vb: System.Collections.Generic.IAsyncEnumerable(Of TOut)
  name.vb: IAsyncEnumerable(Of TOut)
  spec.csharp:
  - uid: System.Collections.Generic.IAsyncEnumerable`1
    name: IAsyncEnumerable
    nameWithType: IAsyncEnumerable
    fullName: System.Collections.Generic.IAsyncEnumerable
    isExternal: true
  - name: <
    nameWithType: <
    fullName: <
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IAsyncEnumerable`1
    name: IAsyncEnumerable
    nameWithType: IAsyncEnumerable
    fullName: System.Collections.Generic.IAsyncEnumerable
    isExternal: true
  - name: '(Of '
    nameWithType: '(Of '
    fullName: '(Of '
  - name: TOut
    nameWithType: TOut
    fullName: TOut
  - name: )
    nameWithType: )
    fullName: )
- uid: Open.ChannelExtensions.Extensions.ToChannelAsync*
  commentId: Overload:Open.ChannelExtensions.Extensions.ToChannelAsync
  name: ToChannelAsync
  nameWithType: Extensions.ToChannelAsync
  fullName: Open.ChannelExtensions.Extensions.ToChannelAsync
